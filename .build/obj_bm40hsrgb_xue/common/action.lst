   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  59:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  62:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  63:tmk_core/common/action.c **** #endif
  64:tmk_core/common/action.c **** /** \brief Called to execute an action.
  65:tmk_core/common/action.c ****  *
  66:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  67:tmk_core/common/action.c ****  */
  68:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 68 36 view -0
  17               		.cfi_startproc
  18 0000 DF92      		push r13
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 13, -2
  22 0002 EF92      		push r14
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 14, -3
  26 0004 FF92      		push r15
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 15, -4
  30 0006 0F93      		push r16
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 16, -5
  34 0008 1F93      		push r17
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 17, -6
  38 000a CF93      		push r28
  39               	.LCFI5:
  40               		.cfi_def_cfa_offset 8
  41               		.cfi_offset 28, -7
  42 000c DF93      		push r29
  43               	.LCFI6:
  44               		.cfi_def_cfa_offset 9
  45               		.cfi_offset 29, -8
  46 000e CDB7      		in r28,__SP_L__
  47 0010 DEB7      		in r29,__SP_H__
  48               	.LCFI7:
  49               		.cfi_def_cfa_register 28
  50 0012 2B97      		sbiw r28,11
  51               	.LCFI8:
  52               		.cfi_def_cfa_offset 20
  53 0014 0FB6      		in __tmp_reg__,__SREG__
  54 0016 F894      		cli
  55 0018 DEBF      		out __SP_H__,r29
  56 001a 0FBE      		out __SREG__,__tmp_reg__
  57 001c CDBF      		out __SP_L__,r28
  58               	/* prologue: function */
  59               	/* frame size = 11 */
  60               	/* stack size = 18 */
  61               	.L__stack_usage = 18
  62 001e 7A87      		std Y+10,r23
  63 0020 8B87      		std Y+11,r24
  64 0022 F42E      		mov r15,r20
  65               	.LVL0:
  66               		.loc 1 68 36 is_stmt 0 view .LVU1
  67 0024 052F      		mov r16,r21
  68               	.LVL1:
  69               		.loc 1 68 36 view .LVU2
  70 0026 162F      		mov r17,r22
  71               	.LVL2:
  72               		.loc 1 68 36 view .LVU3
  73 0028 E72E      		mov r14,r23
  74 002a D82E      		mov r13,r24
  75               	.LVL3:
  69:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  76               		.loc 1 69 5 is_stmt 1 view .LVU4
  70:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  71:tmk_core/common/action.c ****         dprint("EVENT: ");
  72:tmk_core/common/action.c ****         debug_event(event);
  73:tmk_core/common/action.c ****         dprintln();
  77               		.loc 1 73 19 view .LVU5
  74:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  75:tmk_core/common/action.c ****         retro_tapping_counter++;
  76:tmk_core/common/action.c **** #endif
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c **** 
  79:tmk_core/common/action.c ****     if (event.pressed) {
  78               		.loc 1 79 5 view .LVU6
  79               		.loc 1 79 8 is_stmt 0 view .LVU7
  80 002c 6111      		cpse r22,__zero_reg__
  80:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
  81:tmk_core/common/action.c ****         clear_weak_mods();
  81               		.loc 1 81 9 is_stmt 1 view .LVU8
  82 002e 0E94 0000 		call clear_weak_mods
  83               	.LVL4:
  84               	.L2:
  82:tmk_core/common/action.c ****     }
  83:tmk_core/common/action.c **** 
  84:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  85:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  86:tmk_core/common/action.c ****         process_hand_swap(&event);
  87:tmk_core/common/action.c ****     }
  88:tmk_core/common/action.c **** #endif
  89:tmk_core/common/action.c **** 
  90:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  85               		.loc 1 90 5 view .LVU9
  86               		.loc 1 90 17 is_stmt 0 view .LVU10
  87 0032 1E82      		std Y+6,__zero_reg__
  88 0034 1D82      		std Y+5,__zero_reg__
  89 0036 7E2D      		mov r23,r14
  90 0038 EC82      		std Y+4,r14
  91 003a DD82      		std Y+5,r13
  91:tmk_core/common/action.c **** 
  92:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  93:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  94:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  95:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  98:tmk_core/common/action.c ****         clear_oneshot_mods();
  99:tmk_core/common/action.c ****     }
 100:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 101:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 102:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 103:tmk_core/common/action.c ****     }
 104:tmk_core/common/action.c **** #        endif
 105:tmk_core/common/action.c **** #    endif
 106:tmk_core/common/action.c **** #endif
 107:tmk_core/common/action.c **** 
 108:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 109:tmk_core/common/action.c ****     action_tapping_process(record);
  92               		.loc 1 109 5 is_stmt 1 view .LVU11
  93 003c 4F2D      		mov r20,r15
  94 003e 502F      		mov r21,r16
  95 0040 612F      		mov r22,r17
  96 0042 8D2D      		mov r24,r13
  97 0044 9E81      		ldd r25,Y+6
  98               	/* epilogue start */
 110:tmk_core/common/action.c **** #else
 111:tmk_core/common/action.c ****     process_record(&record);
 112:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:tmk_core/common/action.c ****         dprint("processed: ");
 114:tmk_core/common/action.c ****         debug_record(record);
 115:tmk_core/common/action.c ****         dprintln();
 116:tmk_core/common/action.c ****     }
 117:tmk_core/common/action.c **** #endif
 118:tmk_core/common/action.c **** }
  99               		.loc 1 118 1 is_stmt 0 view .LVU12
 100 0046 2B96      		adiw r28,11
 101 0048 0FB6      		in __tmp_reg__,__SREG__
 102 004a F894      		cli
 103 004c DEBF      		out __SP_H__,r29
 104 004e 0FBE      		out __SREG__,__tmp_reg__
 105 0050 CDBF      		out __SP_L__,r28
 106 0052 DF91      		pop r29
 107 0054 CF91      		pop r28
 108 0056 1F91      		pop r17
 109               	.LVL5:
 110               		.loc 1 118 1 view .LVU13
 111 0058 0F91      		pop r16
 112               	.LVL6:
 113               		.loc 1 118 1 view .LVU14
 114 005a FF90      		pop r15
 115               	.LVL7:
 116               		.loc 1 118 1 view .LVU15
 117 005c EF90      		pop r14
 118               	.LVL8:
 119               		.loc 1 118 1 view .LVU16
 120 005e DF90      		pop r13
 121               	.LVL9:
 109:tmk_core/common/action.c **** #else
 122               		.loc 1 109 5 view .LVU17
 123 0060 0C94 0000 		jmp action_tapping_process
 124               	.LVL10:
 109:tmk_core/common/action.c **** #else
 125               		.loc 1 109 5 view .LVU18
 126               		.cfi_endproc
 127               	.LFE15:
 129               		.section	.text.process_record_quantum,"ax",@progbits
 130               		.weak	process_record_quantum
 132               	process_record_quantum:
 133               	.LVL11:
 134               	.LFB17:
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:tmk_core/common/action.c **** bool swap_hands = false;
 122:tmk_core/common/action.c **** bool swap_held  = false;
 123:tmk_core/common/action.c **** 
 124:tmk_core/common/action.c **** /** \brief Process Hand Swap
 125:tmk_core/common/action.c ****  *
 126:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 127:tmk_core/common/action.c ****  */
 128:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 129:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 132:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 133:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 134:tmk_core/common/action.c **** 
 135:tmk_core/common/action.c ****     if (do_swap) {
 136:tmk_core/common/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 137:tmk_core/common/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 135               		.loc 1 157 72 is_stmt 1 view -0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 141               		.loc 1 157 74 view .LVU20
 142               		.loc 1 157 1 is_stmt 0 view .LVU21
 143 0000 81E0      		ldi r24,lo8(1)
 144               	.LVL12:
 145               	/* epilogue start */
 146               		.loc 1 157 1 view .LVU22
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE17:
 151               		.section	.text.post_process_record_quantum,"ax",@progbits
 152               		.weak	post_process_record_quantum
 154               	post_process_record_quantum:
 155               	.LVL13:
 156               	.LFB18:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 157               		.loc 1 159 77 is_stmt 1 view -0
 158               		.cfi_startproc
 159               	/* prologue: function */
 160               	/* frame size = 0 */
 161               	/* stack size = 0 */
 162               	.L__stack_usage = 0
 163               		.loc 1 159 78 view .LVU24
 164               	/* epilogue start */
 165               		.loc 1 159 1 is_stmt 0 view .LVU25
 166 0000 0895      		ret
 167               		.cfi_endproc
 168               	.LFE18:
 170               		.section	.text.process_record_tap_hint,"ax",@progbits
 171               	.global	process_record_tap_hint
 173               	process_record_tap_hint:
 174               	.LVL14:
 175               	.LFB19:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 176               		.loc 1 166 51 is_stmt 1 view -0
 177               		.cfi_startproc
 178               	/* prologue: function */
 179               	/* frame size = 0 */
 180               	/* stack size = 0 */
 181               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 182               		.loc 1 167 5 view .LVU27
 183               		.loc 1 167 23 is_stmt 0 view .LVU28
 184 0000 FC01      		movw r30,r24
 185 0002 8081      		ld r24,Z
 186 0004 9181      		ldd r25,Z+1
 187               	.LVL15:
 188               		.loc 1 167 23 view .LVU29
 189 0006 0C94 0000 		jmp layer_switch_get_action
 190               	.LVL16:
 191               		.loc 1 167 23 view .LVU30
 192               		.cfi_endproc
 193               	.LFE19:
 195               		.section	.text.register_code,"ax",@progbits
 196               	.global	register_code
 198               	register_code:
 199               	.LVL17:
 200               	.LFB23:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 224:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 225:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 226:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 227:tmk_core/common/action.c **** #    endif
 228:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 229:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 230:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 231:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 232:tmk_core/common/action.c **** #    endif
 233:tmk_core/common/action.c **** }
 234:tmk_core/common/action.c **** #endif
 235:tmk_core/common/action.c **** 
 236:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 237:tmk_core/common/action.c ****  *
 238:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 239:tmk_core/common/action.c ****  */
 240:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 241:tmk_core/common/action.c ****     keyevent_t event = record->event;
 242:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 243:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 244:tmk_core/common/action.c **** #endif
 245:tmk_core/common/action.c **** 
 246:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 247:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 248:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 249:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 250:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 251:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 252:tmk_core/common/action.c **** #    endif
 253:tmk_core/common/action.c ****     ) {
 254:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 255:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 256:tmk_core/common/action.c ****     }
 257:tmk_core/common/action.c **** #endif
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c ****     switch (action.kind.id) {
 260:tmk_core/common/action.c ****         /* Key and Mods */
 261:tmk_core/common/action.c ****         case ACT_LMODS:
 262:tmk_core/common/action.c ****         case ACT_RMODS: {
 263:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 264:tmk_core/common/action.c ****             if (event.pressed) {
 265:tmk_core/common/action.c ****                 if (mods) {
 266:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 267:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 268:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 269:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 270:tmk_core/common/action.c ****                         add_mods(mods);
 271:tmk_core/common/action.c ****                     } else {
 272:tmk_core/common/action.c ****                         add_weak_mods(mods);
 273:tmk_core/common/action.c ****                     }
 274:tmk_core/common/action.c ****                     send_keyboard_report();
 275:tmk_core/common/action.c ****                 }
 276:tmk_core/common/action.c ****                 register_code(action.key.code);
 277:tmk_core/common/action.c ****             } else {
 278:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 279:tmk_core/common/action.c ****                 if (mods) {
 280:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 281:tmk_core/common/action.c ****                         del_mods(mods);
 282:tmk_core/common/action.c ****                     } else {
 283:tmk_core/common/action.c ****                         del_weak_mods(mods);
 284:tmk_core/common/action.c ****                     }
 285:tmk_core/common/action.c ****                     send_keyboard_report();
 286:tmk_core/common/action.c ****                 }
 287:tmk_core/common/action.c ****             }
 288:tmk_core/common/action.c ****         } break;
 289:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 290:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 291:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 292:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 293:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 294:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 295:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 296:tmk_core/common/action.c ****                     // Oneshot modifier
 297:tmk_core/common/action.c ****                     if (event.pressed) {
 298:tmk_core/common/action.c ****                         if (tap_count == 0) {
 299:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 300:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 301:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 302:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 303:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 304:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 305:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 306:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 308:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 309:tmk_core/common/action.c ****                             register_mods(mods);
 310:tmk_core/common/action.c **** #        endif
 311:tmk_core/common/action.c ****                         } else {
 312:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 313:tmk_core/common/action.c ****                         }
 314:tmk_core/common/action.c ****                     } else {
 315:tmk_core/common/action.c ****                         if (tap_count == 0) {
 316:tmk_core/common/action.c ****                             clear_oneshot_mods();
 317:tmk_core/common/action.c ****                             unregister_mods(mods);
 318:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 319:tmk_core/common/action.c ****                             // Retain Oneshot mods
 320:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 321:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 322:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 323:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 324:tmk_core/common/action.c ****                                 unregister_mods(mods);
 325:tmk_core/common/action.c ****                             }
 326:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 327:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 328:tmk_core/common/action.c **** #        endif
 329:tmk_core/common/action.c ****                         } else {
 330:tmk_core/common/action.c ****                             clear_oneshot_mods();
 331:tmk_core/common/action.c ****                             unregister_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     }
 334:tmk_core/common/action.c ****                     break;
 335:tmk_core/common/action.c **** #    endif
 336:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 337:tmk_core/common/action.c ****                     if (event.pressed) {
 338:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 339:tmk_core/common/action.c ****                             register_mods(mods);
 340:tmk_core/common/action.c ****                         }
 341:tmk_core/common/action.c ****                     } else {
 342:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 344:tmk_core/common/action.c ****                         }
 345:tmk_core/common/action.c ****                     }
 346:tmk_core/common/action.c ****                     break;
 347:tmk_core/common/action.c ****                 default:
 348:tmk_core/common/action.c ****                     if (event.pressed) {
 349:tmk_core/common/action.c ****                         if (tap_count > 0) {
 350:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 351:tmk_core/common/action.c ****                             if (
 352:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 353:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 354:tmk_core/common/action.c **** #        endif
 355:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 356:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 357:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 358:tmk_core/common/action.c ****                                 record->tap.count = 0;
 359:tmk_core/common/action.c ****                                 register_mods(mods);
 360:tmk_core/common/action.c ****                             } else
 361:tmk_core/common/action.c **** #    endif
 362:tmk_core/common/action.c ****                             {
 363:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 364:tmk_core/common/action.c ****                                 register_code(action.key.code);
 365:tmk_core/common/action.c ****                             }
 366:tmk_core/common/action.c ****                         } else {
 367:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 368:tmk_core/common/action.c ****                             register_mods(mods);
 369:tmk_core/common/action.c ****                         }
 370:tmk_core/common/action.c ****                     } else {
 371:tmk_core/common/action.c ****                         if (tap_count > 0) {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 373:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 374:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 375:tmk_core/common/action.c ****                             } else {
 376:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 377:tmk_core/common/action.c ****                             }
 378:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             unregister_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     }
 384:tmk_core/common/action.c ****                     break;
 385:tmk_core/common/action.c ****             }
 386:tmk_core/common/action.c ****         } break;
 387:tmk_core/common/action.c **** #endif
 388:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 389:tmk_core/common/action.c ****         /* other HID usage */
 390:tmk_core/common/action.c ****         case ACT_USAGE:
 391:tmk_core/common/action.c ****             switch (action.usage.page) {
 392:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 393:tmk_core/common/action.c ****                     if (event.pressed) {
 394:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 395:tmk_core/common/action.c ****                     } else {
 396:tmk_core/common/action.c ****                         host_system_send(0);
 397:tmk_core/common/action.c ****                     }
 398:tmk_core/common/action.c ****                     break;
 399:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 400:tmk_core/common/action.c ****                     if (event.pressed) {
 401:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 402:tmk_core/common/action.c ****                     } else {
 403:tmk_core/common/action.c ****                         host_consumer_send(0);
 404:tmk_core/common/action.c ****                     }
 405:tmk_core/common/action.c ****                     break;
 406:tmk_core/common/action.c ****             }
 407:tmk_core/common/action.c ****             break;
 408:tmk_core/common/action.c **** #endif
 409:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 410:tmk_core/common/action.c ****         /* Mouse key */
 411:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 412:tmk_core/common/action.c ****             if (event.pressed) {
 413:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 414:tmk_core/common/action.c ****             } else {
 415:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 416:tmk_core/common/action.c ****             }
 417:tmk_core/common/action.c ****             switch (action.key.code) {
 418:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 419:tmk_core/common/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 420:tmk_core/common/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 421:tmk_core/common/action.c **** #        else
 422:tmk_core/common/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 423:tmk_core/common/action.c **** #        endif
 424:tmk_core/common/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 425:tmk_core/common/action.c ****                     break;
 426:tmk_core/common/action.c **** #    endif
 427:tmk_core/common/action.c ****                 default:
 428:tmk_core/common/action.c ****                     mousekey_send();
 429:tmk_core/common/action.c ****                     break;
 430:tmk_core/common/action.c ****             }
 431:tmk_core/common/action.c ****             break;
 432:tmk_core/common/action.c **** #endif
 433:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 434:tmk_core/common/action.c ****         case ACT_LAYER:
 435:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 436:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 437:tmk_core/common/action.c ****                 if (!event.pressed) {
 438:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 439:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 440:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 441:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 442:tmk_core/common/action.c ****                         case OP_BIT_AND:
 443:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 444:tmk_core/common/action.c ****                             break;
 445:tmk_core/common/action.c ****                         case OP_BIT_OR:
 446:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 447:tmk_core/common/action.c ****                             break;
 448:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 449:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 450:tmk_core/common/action.c ****                             break;
 451:tmk_core/common/action.c ****                         case OP_BIT_SET:
 452:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 453:tmk_core/common/action.c ****                             break;
 454:tmk_core/common/action.c ****                     }
 455:tmk_core/common/action.c ****                 }
 456:tmk_core/common/action.c ****             } else {
 457:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 458:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 459:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 460:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 461:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 462:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 463:tmk_core/common/action.c ****                         case OP_BIT_AND:
 464:tmk_core/common/action.c ****                             layer_and(bits | mask);
 465:tmk_core/common/action.c ****                             break;
 466:tmk_core/common/action.c ****                         case OP_BIT_OR:
 467:tmk_core/common/action.c ****                             layer_or(bits | mask);
 468:tmk_core/common/action.c ****                             break;
 469:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 470:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 471:tmk_core/common/action.c ****                             break;
 472:tmk_core/common/action.c ****                         case OP_BIT_SET:
 473:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 474:tmk_core/common/action.c ****                             break;
 475:tmk_core/common/action.c ****                     }
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 480:tmk_core/common/action.c ****             if (event.pressed) {
 481:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 482:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 483:tmk_core/common/action.c ****             } else {
 484:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 485:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 486:tmk_core/common/action.c ****             }
 487:tmk_core/common/action.c ****             break;
 488:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 489:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 490:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 491:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 492:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 493:tmk_core/common/action.c ****                     /* tap toggle */
 494:tmk_core/common/action.c ****                     if (event.pressed) {
 495:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 496:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 497:tmk_core/common/action.c ****                         }
 498:tmk_core/common/action.c ****                     } else {
 499:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 500:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 501:tmk_core/common/action.c ****                         }
 502:tmk_core/common/action.c ****                     }
 503:tmk_core/common/action.c ****                     break;
 504:tmk_core/common/action.c ****                 case OP_ON_OFF:
 505:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 506:tmk_core/common/action.c ****                     break;
 507:tmk_core/common/action.c ****                 case OP_OFF_ON:
 508:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 509:tmk_core/common/action.c ****                     break;
 510:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 511:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 512:tmk_core/common/action.c ****                     break;
 513:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 514:tmk_core/common/action.c ****                 case OP_ONESHOT:
 515:tmk_core/common/action.c ****                     // Oneshot modifier
 516:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 517:tmk_core/common/action.c ****                     do_release_oneshot = false;
 518:tmk_core/common/action.c ****                     if (event.pressed) {
 519:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 520:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 521:tmk_core/common/action.c ****                             reset_oneshot_layer();
 522:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 523:tmk_core/common/action.c ****                             break;
 524:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 525:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 526:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 527:tmk_core/common/action.c ****                         }
 528:tmk_core/common/action.c ****                     } else {
 529:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 533:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 534:tmk_core/common/action.c ****                         } else {
 535:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 536:tmk_core/common/action.c ****                         }
 537:tmk_core/common/action.c ****                     }
 538:tmk_core/common/action.c **** #            else
 539:tmk_core/common/action.c ****                     if (event.pressed) {
 540:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 541:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 542:tmk_core/common/action.c ****                     } else {
 543:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 544:tmk_core/common/action.c ****                         if (tap_count > 1) {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            endif
 549:tmk_core/common/action.c ****                     break;
 550:tmk_core/common/action.c **** #        endif
 551:tmk_core/common/action.c ****                 default:
 552:tmk_core/common/action.c ****                     /* tap key */
 553:tmk_core/common/action.c ****                     if (event.pressed) {
 554:tmk_core/common/action.c ****                         if (tap_count > 0) {
 555:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 556:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 557:tmk_core/common/action.c ****                         } else {
 558:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 559:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 560:tmk_core/common/action.c ****                         }
 561:tmk_core/common/action.c ****                     } else {
 562:tmk_core/common/action.c ****                         if (tap_count > 0) {
 563:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 564:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 565:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 566:tmk_core/common/action.c ****                             } else {
 567:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 568:tmk_core/common/action.c ****                             }
 569:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 570:tmk_core/common/action.c ****                         } else {
 571:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 572:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 573:tmk_core/common/action.c ****                         }
 574:tmk_core/common/action.c ****                     }
 575:tmk_core/common/action.c ****                     break;
 576:tmk_core/common/action.c ****             }
 577:tmk_core/common/action.c ****             break;
 578:tmk_core/common/action.c **** #    endif
 579:tmk_core/common/action.c **** #endif
 580:tmk_core/common/action.c ****             /* Extentions */
 581:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 582:tmk_core/common/action.c ****         case ACT_MACRO:
 583:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 584:tmk_core/common/action.c ****             break;
 585:tmk_core/common/action.c **** #endif
 586:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 587:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 588:tmk_core/common/action.c ****             switch (action.swap.code) {
 589:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 590:tmk_core/common/action.c ****                     if (event.pressed) {
 591:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 592:tmk_core/common/action.c ****                     }
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 595:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 598:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 599:tmk_core/common/action.c ****                     break;
 600:tmk_core/common/action.c ****                 case OP_SH_ON:
 601:tmk_core/common/action.c ****                     if (!event.pressed) {
 602:tmk_core/common/action.c ****                         swap_hands = true;
 603:tmk_core/common/action.c ****                     }
 604:tmk_core/common/action.c ****                     break;
 605:tmk_core/common/action.c ****                 case OP_SH_OFF:
 606:tmk_core/common/action.c ****                     if (!event.pressed) {
 607:tmk_core/common/action.c ****                         swap_hands = false;
 608:tmk_core/common/action.c ****                     }
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 611:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 612:tmk_core/common/action.c ****                     if (event.pressed) {
 613:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 614:tmk_core/common/action.c ****                     } else {
 615:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 616:tmk_core/common/action.c ****                     }
 617:tmk_core/common/action.c ****                     break;
 618:tmk_core/common/action.c **** #    endif
 619:tmk_core/common/action.c **** 
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 621:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 622:tmk_core/common/action.c ****                     /* tap toggle */
 623:tmk_core/common/action.c **** 
 624:tmk_core/common/action.c ****                     if (event.pressed) {
 625:tmk_core/common/action.c ****                         if (swap_held) {
 626:tmk_core/common/action.c ****                             swap_held = false;
 627:tmk_core/common/action.c ****                         } else {
 628:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 629:tmk_core/common/action.c ****                         }
 630:tmk_core/common/action.c ****                     } else {
 631:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 632:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 633:tmk_core/common/action.c ****                         }
 634:tmk_core/common/action.c ****                     }
 635:tmk_core/common/action.c ****                     break;
 636:tmk_core/common/action.c ****                 default:
 637:tmk_core/common/action.c ****                     /* tap key */
 638:tmk_core/common/action.c ****                     if (tap_count > 0) {
 639:tmk_core/common/action.c ****                         if (swap_held) {
 640:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 641:tmk_core/common/action.c ****                             swap_held  = false;
 642:tmk_core/common/action.c ****                         }
 643:tmk_core/common/action.c ****                         if (event.pressed) {
 644:tmk_core/common/action.c ****                             register_code(action.swap.code);
 645:tmk_core/common/action.c ****                         } else {
 646:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 647:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 648:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 649:tmk_core/common/action.c ****                         }
 650:tmk_core/common/action.c ****                     } else {
 651:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 652:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 653:tmk_core/common/action.c ****                             swap_held  = false;
 654:tmk_core/common/action.c ****                         }
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c **** #    endif
 657:tmk_core/common/action.c ****             }
 658:tmk_core/common/action.c **** #endif
 659:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 660:tmk_core/common/action.c ****         case ACT_FUNCTION:
 661:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c **** #endif
 664:tmk_core/common/action.c ****         default:
 665:tmk_core/common/action.c ****             break;
 666:tmk_core/common/action.c ****     }
 667:tmk_core/common/action.c **** 
 668:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 669:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 670:tmk_core/common/action.c ****     switch (action.kind.id) {
 671:tmk_core/common/action.c ****         case ACT_LAYER:
 672:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 673:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 674:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 675:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 676:tmk_core/common/action.c **** #    endif
 677:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 678:tmk_core/common/action.c ****             break;
 679:tmk_core/common/action.c ****         default:
 680:tmk_core/common/action.c ****             break;
 681:tmk_core/common/action.c ****     }
 682:tmk_core/common/action.c **** #endif
 683:tmk_core/common/action.c **** 
 684:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 685:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 686:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 687:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 688:tmk_core/common/action.c ****     } else {
 689:tmk_core/common/action.c ****         if (event.pressed) {
 690:tmk_core/common/action.c ****             if (tap_count > 0) {
 691:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 692:tmk_core/common/action.c ****             }
 693:tmk_core/common/action.c ****         } else {
 694:tmk_core/common/action.c ****             if (tap_count > 0) {
 695:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 696:tmk_core/common/action.c ****             } else {
 697:tmk_core/common/action.c ****                 if (
 698:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 699:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 700:tmk_core/common/action.c **** #        endif
 701:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 702:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 703:tmk_core/common/action.c ****                 }
 704:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 705:tmk_core/common/action.c ****             }
 706:tmk_core/common/action.c ****         }
 707:tmk_core/common/action.c ****     }
 708:tmk_core/common/action.c **** #    endif
 709:tmk_core/common/action.c **** #endif
 710:tmk_core/common/action.c **** 
 711:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 712:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 713:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 714:tmk_core/common/action.c ****         use_oneshot_swaphands();
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** #    endif
 717:tmk_core/common/action.c **** #endif
 718:tmk_core/common/action.c **** 
 719:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 721:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 722:tmk_core/common/action.c ****      */
 723:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 724:tmk_core/common/action.c ****         record->event.pressed = false;
 725:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 726:tmk_core/common/action.c ****         process_record(record);
 727:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** }
 731:tmk_core/common/action.c **** 
 732:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 733:tmk_core/common/action.c ****  *
 734:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 735:tmk_core/common/action.c ****  */
 736:tmk_core/common/action.c **** void register_code(uint8_t code) {
 201               		.loc 1 736 34 is_stmt 1 view -0
 202               		.cfi_startproc
 203               		.loc 1 736 34 is_stmt 0 view .LVU32
 204 0000 CF93      		push r28
 205               	.LCFI9:
 206               		.cfi_def_cfa_offset 3
 207               		.cfi_offset 28, -2
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 1 */
 211               	.L__stack_usage = 1
 212 0002 C82F      		mov r28,r24
 737:tmk_core/common/action.c ****     if (code == KC_NO) {
 213               		.loc 1 737 5 is_stmt 1 view .LVU33
 214               		.loc 1 737 8 is_stmt 0 view .LVU34
 215 0004 8823      		tst r24
 216 0006 01F4      		brne .+2
 217 0008 00C0      		rjmp .L9
 738:tmk_core/common/action.c ****         return;
 739:tmk_core/common/action.c ****     }
 740:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 741:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 218               		.loc 1 741 10 is_stmt 1 view .LVU35
 219               		.loc 1 741 13 is_stmt 0 view .LVU36
 220 000a 8238      		cpi r24,lo8(-126)
 221 000c 01F4      		brne .L12
 742:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 743:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 744:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 222               		.loc 1 744 9 is_stmt 1 view .LVU37
 223               		.loc 1 744 13 is_stmt 0 view .LVU38
 224 000e 0E94 0000 		call host_keyboard_leds
 225               	.LVL18:
 226               		.loc 1 744 12 view .LVU39
 227 0012 81FD      		sbrc r24,1
 228 0014 00C0      		rjmp .L9
 745:tmk_core/common/action.c **** #    endif
 746:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 229               		.loc 1 746 9 is_stmt 1 view .LVU40
 230 0016 89E3      		ldi r24,lo8(57)
 231 0018 0E94 0000 		call add_key
 232               	.LVL19:
 747:tmk_core/common/action.c ****         send_keyboard_report();
 233               		.loc 1 747 9 view .LVU41
 234 001c 0E94 0000 		call send_keyboard_report
 235               	.LVL20:
 748:tmk_core/common/action.c ****         wait_ms(100);
 236               		.loc 1 748 9 view .LVU42
 237               	.LBB33:
 238               	.LBI33:
 239               		.file 2 "c:\\qmk_msys\\mingw64\\avr\\include\\util\\delay.h"
   1:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    All rights reserved.
   5:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
   6:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
   9:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\qmk_msys\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  12:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\qmk_msys\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\qmk_msys\mingw64\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\qmk_msys\mingw64\avr\include\util\delay.h ****      distribution.
  16:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  17:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\qmk_msys\mingw64\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\qmk_msys\mingw64\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  21:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  33:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  35:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  38:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #  endif
  42:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  44:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #include <math.h>
  47:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  48:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /** \file */
  49:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     \code
  51:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     \endcode
  55:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  56:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     used.
  60:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  61:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  70:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  79:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  83:c:\qmk_msys\mingw64\avr\include\util\delay.h **** */
  84:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  85:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\qmk_msys\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\qmk_msys\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
  89:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  90:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\qmk_msys\mingw64\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     \def F_CPU
  95:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
  97:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 103:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\qmk_msys\mingw64\avr\include\util\delay.h ****     integer value.
 107:c:\qmk_msys\mingw64\avr\include\util\delay.h ****  */
 108:c:\qmk_msys\mingw64\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
 110:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 111:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\qmk_msys\mingw64\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
 114:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 115:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #  include <math.h>
 119:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #endif
 120:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 121:c:\qmk_msys\mingw64\avr\include\util\delay.h **** /**
 122:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 124:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 126:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 129:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 131:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 137:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 142:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 147:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    respectively.
 151:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 152:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    \note
 153:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 154:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\qmk_msys\mingw64\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 164:c:\qmk_msys\mingw64\avr\include\util\delay.h ****  */
 165:c:\qmk_msys\mingw64\avr\include\util\delay.h **** void
 166:c:\qmk_msys\mingw64\avr\include\util\delay.h **** _delay_ms(double __ms)
 240               		.loc 2 166 1 view .LVU43
 241               	.LBB34:
 167:c:\qmk_msys\mingw64\avr\include\util\delay.h **** {
 168:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	double __tmp ;
 242               		.loc 2 168 2 view .LVU44
 169:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\qmk_msys\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 243               		.loc 2 172 2 view .LVU45
 173:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 244               		.loc 2 173 2 view .LVU46
 174:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 245               		.loc 2 174 2 view .LVU47
 175:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 176:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 179:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 182:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#else
 183:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 		//round up by default
 184:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 246               		.loc 2 184 3 view .LVU48
 185:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 186:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 187:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 247               		.loc 2 187 2 view .LVU49
 248 0020 2FEF      		ldi r18,lo8(319999)
 249 0022 81EE      		ldi r24,hi8(319999)
 250 0024 94E0      		ldi r25,hlo8(319999)
 251 0026 2150      	1:	subi r18,1
 252 0028 8040      		sbci r24,0
 253 002a 9040      		sbci r25,0
 254 002c 01F4      		brne 1b
 255 002e 00C0      		rjmp .
 256 0030 0000      		nop
 257               	.LVL21:
 258               		.loc 2 187 2 is_stmt 0 view .LVU50
 259               	.LBE34:
 260               	.LBE33:
 749:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 261               		.loc 1 749 9 is_stmt 1 view .LVU51
 262 0032 89E3      		ldi r24,lo8(57)
 263               	.L24:
 750:tmk_core/common/action.c ****         send_keyboard_report();
 751:tmk_core/common/action.c ****     }
 752:tmk_core/common/action.c **** 
 753:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 754:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 755:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 756:tmk_core/common/action.c **** #    endif
 757:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 758:tmk_core/common/action.c ****         send_keyboard_report();
 759:tmk_core/common/action.c ****         wait_ms(100);
 760:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 264               		.loc 1 760 9 is_stmt 0 view .LVU52
 265 0034 0E94 0000 		call del_key
 266               	.LVL22:
 267               	.L25:
 761:tmk_core/common/action.c ****         send_keyboard_report();
 268               		.loc 1 761 9 is_stmt 1 view .LVU53
 269               	/* epilogue start */
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** 
 764:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 765:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 766:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 767:tmk_core/common/action.c **** #    endif
 768:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 769:tmk_core/common/action.c ****         send_keyboard_report();
 770:tmk_core/common/action.c ****         wait_ms(100);
 771:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 772:tmk_core/common/action.c ****         send_keyboard_report();
 773:tmk_core/common/action.c ****     }
 774:tmk_core/common/action.c **** #endif
 775:tmk_core/common/action.c **** 
 776:tmk_core/common/action.c ****     else if IS_KEY (code) {
 777:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 778:tmk_core/common/action.c ****         if (command_proc(code)) return;
 779:tmk_core/common/action.c **** 
 780:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 781:tmk_core/common/action.c **** /* TODO: remove
 782:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 783:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 784:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 785:tmk_core/common/action.c **** 
 786:tmk_core/common/action.c ****             add_key(code);
 787:tmk_core/common/action.c ****             send_keyboard_report();
 788:tmk_core/common/action.c **** 
 789:tmk_core/common/action.c ****             set_mods(tmp_mods);
 790:tmk_core/common/action.c ****             send_keyboard_report();
 791:tmk_core/common/action.c ****             oneshot_cancel();
 792:tmk_core/common/action.c ****         } else
 793:tmk_core/common/action.c **** */
 794:tmk_core/common/action.c **** #endif
 795:tmk_core/common/action.c ****         {
 796:tmk_core/common/action.c ****             // Force a new key press if the key is already pressed
 797:tmk_core/common/action.c ****             // without this, keys with the same keycode, but different
 798:tmk_core/common/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 799:tmk_core/common/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 800:tmk_core/common/action.c ****                 del_key(code);
 801:tmk_core/common/action.c ****                 send_keyboard_report();
 802:tmk_core/common/action.c ****             }
 803:tmk_core/common/action.c ****             add_key(code);
 804:tmk_core/common/action.c ****             send_keyboard_report();
 805:tmk_core/common/action.c ****         }
 806:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 807:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 811:tmk_core/common/action.c ****     else if IS_SYSTEM (code) {
 812:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 813:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 814:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 815:tmk_core/common/action.c ****     }
 816:tmk_core/common/action.c **** #endif
 817:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 818:tmk_core/common/action.c ****     else if IS_MOUSEKEY (code) {
 819:tmk_core/common/action.c ****         mousekey_on(code);
 820:tmk_core/common/action.c ****         mousekey_send();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** #endif
 823:tmk_core/common/action.c **** }
 270               		.loc 1 823 1 is_stmt 0 view .LVU54
 271 0038 CF91      		pop r28
 761:tmk_core/common/action.c ****         send_keyboard_report();
 272               		.loc 1 761 9 view .LVU55
 273 003a 0C94 0000 		jmp send_keyboard_report
 274               	.LVL23:
 275               	.L12:
 753:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 276               		.loc 1 753 10 is_stmt 1 view .LVU56
 753:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 277               		.loc 1 753 13 is_stmt 0 view .LVU57
 278 003e 8338      		cpi r24,lo8(-125)
 279 0040 01F4      		brne .L14
 755:tmk_core/common/action.c **** #    endif
 280               		.loc 1 755 9 is_stmt 1 view .LVU58
 755:tmk_core/common/action.c **** #    endif
 281               		.loc 1 755 13 is_stmt 0 view .LVU59
 282 0042 0E94 0000 		call host_keyboard_leds
 283               	.LVL24:
 755:tmk_core/common/action.c **** #    endif
 284               		.loc 1 755 12 view .LVU60
 285 0046 80FD      		sbrc r24,0
 286 0048 00C0      		rjmp .L9
 757:tmk_core/common/action.c ****         send_keyboard_report();
 287               		.loc 1 757 9 is_stmt 1 view .LVU61
 288 004a 83E5      		ldi r24,lo8(83)
 289 004c 0E94 0000 		call add_key
 290               	.LVL25:
 758:tmk_core/common/action.c ****         wait_ms(100);
 291               		.loc 1 758 9 view .LVU62
 292 0050 0E94 0000 		call send_keyboard_report
 293               	.LVL26:
 759:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 294               		.loc 1 759 9 view .LVU63
 295               	.LBB35:
 296               	.LBI35:
 166:c:\qmk_msys\mingw64\avr\include\util\delay.h **** {
 297               		.loc 2 166 1 view .LVU64
 298               	.LBB36:
 168:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 299               		.loc 2 168 2 view .LVU65
 172:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 300               		.loc 2 172 2 view .LVU66
 173:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 301               		.loc 2 173 2 view .LVU67
 174:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 302               		.loc 2 174 2 view .LVU68
 184:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 303               		.loc 2 184 3 view .LVU69
 304               		.loc 2 187 2 view .LVU70
 305 0054 2FEF      		ldi r18,lo8(319999)
 306 0056 81EE      		ldi r24,hi8(319999)
 307 0058 94E0      		ldi r25,hlo8(319999)
 308 005a 2150      	1:	subi r18,1
 309 005c 8040      		sbci r24,0
 310 005e 9040      		sbci r25,0
 311 0060 01F4      		brne 1b
 312 0062 00C0      		rjmp .
 313 0064 0000      		nop
 314               	.LVL27:
 315               		.loc 2 187 2 is_stmt 0 view .LVU71
 316               	.LBE36:
 317               	.LBE35:
 760:tmk_core/common/action.c ****         send_keyboard_report();
 318               		.loc 1 760 9 is_stmt 1 view .LVU72
 319 0066 83E5      		ldi r24,lo8(83)
 320 0068 00C0      		rjmp .L24
 321               	.LVL28:
 322               	.L14:
 764:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 323               		.loc 1 764 10 view .LVU73
 764:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 324               		.loc 1 764 13 is_stmt 0 view .LVU74
 325 006a 8438      		cpi r24,lo8(-124)
 326 006c 01F4      		brne .L15
 766:tmk_core/common/action.c **** #    endif
 327               		.loc 1 766 9 is_stmt 1 view .LVU75
 766:tmk_core/common/action.c **** #    endif
 328               		.loc 1 766 13 is_stmt 0 view .LVU76
 329 006e 0E94 0000 		call host_keyboard_leds
 330               	.LVL29:
 766:tmk_core/common/action.c **** #    endif
 331               		.loc 1 766 12 view .LVU77
 332 0072 82FD      		sbrc r24,2
 333 0074 00C0      		rjmp .L9
 768:tmk_core/common/action.c ****         send_keyboard_report();
 334               		.loc 1 768 9 is_stmt 1 view .LVU78
 335 0076 87E4      		ldi r24,lo8(71)
 336 0078 0E94 0000 		call add_key
 337               	.LVL30:
 769:tmk_core/common/action.c ****         wait_ms(100);
 338               		.loc 1 769 9 view .LVU79
 339 007c 0E94 0000 		call send_keyboard_report
 340               	.LVL31:
 770:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 341               		.loc 1 770 9 view .LVU80
 342               	.LBB37:
 343               	.LBI37:
 166:c:\qmk_msys\mingw64\avr\include\util\delay.h **** {
 344               		.loc 2 166 1 view .LVU81
 345               	.LBB38:
 168:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 346               		.loc 2 168 2 view .LVU82
 172:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 347               		.loc 2 172 2 view .LVU83
 173:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 348               		.loc 2 173 2 view .LVU84
 174:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 349               		.loc 2 174 2 view .LVU85
 184:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 350               		.loc 2 184 3 view .LVU86
 351               		.loc 2 187 2 view .LVU87
 352 0080 2FEF      		ldi r18,lo8(319999)
 353 0082 81EE      		ldi r24,hi8(319999)
 354 0084 94E0      		ldi r25,hlo8(319999)
 355 0086 2150      	1:	subi r18,1
 356 0088 8040      		sbci r24,0
 357 008a 9040      		sbci r25,0
 358 008c 01F4      		brne 1b
 359 008e 00C0      		rjmp .
 360 0090 0000      		nop
 361               	.LVL32:
 362               		.loc 2 187 2 is_stmt 0 view .LVU88
 363               	.LBE38:
 364               	.LBE37:
 771:tmk_core/common/action.c ****         send_keyboard_report();
 365               		.loc 1 771 9 is_stmt 1 view .LVU89
 366 0092 87E4      		ldi r24,lo8(71)
 367 0094 00C0      		rjmp .L24
 368               	.LVL33:
 369               	.L15:
 776:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 370               		.loc 1 776 10 view .LVU90
 776:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 371               		.loc 1 776 13 is_stmt 0 view .LVU91
 372 0096 8CEF      		ldi r24,lo8(-4)
 373               	.LVL34:
 776:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 374               		.loc 1 776 13 view .LVU92
 375 0098 8C0F      		add r24,r28
 376 009a 813A      		cpi r24,lo8(-95)
 377 009c 00F4      		brsh .L16
 778:tmk_core/common/action.c **** 
 378               		.loc 1 778 9 is_stmt 1 view .LVU93
 799:tmk_core/common/action.c ****                 del_key(code);
 379               		.loc 1 799 13 view .LVU94
 799:tmk_core/common/action.c ****                 del_key(code);
 380               		.loc 1 799 17 is_stmt 0 view .LVU95
 381 009e 6C2F      		mov r22,r28
 382 00a0 8091 0000 		lds r24,keyboard_report
 383 00a4 9091 0000 		lds r25,keyboard_report+1
 384 00a8 0E94 0000 		call is_key_pressed
 385               	.LVL35:
 799:tmk_core/common/action.c ****                 del_key(code);
 386               		.loc 1 799 16 view .LVU96
 387 00ac 8823      		tst r24
 388 00ae 01F0      		breq .L17
 800:tmk_core/common/action.c ****                 send_keyboard_report();
 389               		.loc 1 800 17 is_stmt 1 view .LVU97
 390 00b0 8C2F      		mov r24,r28
 391 00b2 0E94 0000 		call del_key
 392               	.LVL36:
 801:tmk_core/common/action.c ****             }
 393               		.loc 1 801 17 view .LVU98
 394 00b6 0E94 0000 		call send_keyboard_report
 395               	.LVL37:
 396               	.L17:
 803:tmk_core/common/action.c ****             send_keyboard_report();
 397               		.loc 1 803 13 view .LVU99
 398 00ba 8C2F      		mov r24,r28
 399 00bc 0E94 0000 		call add_key
 400               	.LVL38:
 804:tmk_core/common/action.c ****         }
 401               		.loc 1 804 13 view .LVU100
 402 00c0 00C0      		rjmp .L25
 403               	.L16:
 806:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 404               		.loc 1 806 12 view .LVU101
 806:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 405               		.loc 1 806 15 is_stmt 0 view .LVU102
 406 00c2 80E2      		ldi r24,lo8(32)
 407 00c4 8C0F      		add r24,r28
 408 00c6 8830      		cpi r24,lo8(8)
 409 00c8 00F4      		brsh .L18
 807:tmk_core/common/action.c ****         send_keyboard_report();
 410               		.loc 1 807 9 is_stmt 1 view .LVU103
 807:tmk_core/common/action.c ****         send_keyboard_report();
 411               		.loc 1 807 18 is_stmt 0 view .LVU104
 412 00ca C770      		andi r28,lo8(7)
 413               	.LVL39:
 807:tmk_core/common/action.c ****         send_keyboard_report();
 414               		.loc 1 807 9 view .LVU105
 415 00cc 81E0      		ldi r24,lo8(1)
 416 00ce 00C0      		rjmp 2f
 417               		1:
 418 00d0 880F      		lsl r24
 419               		2:
 420 00d2 CA95      		dec r28
 421 00d4 02F4      		brpl 1b
 422 00d6 0E94 0000 		call add_mods
 423               	.LVL40:
 808:tmk_core/common/action.c ****     }
 424               		.loc 1 808 9 is_stmt 1 view .LVU106
 425 00da 00C0      		rjmp .L25
 426               	.LVL41:
 427               	.L18:
 811:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 428               		.loc 1 811 10 view .LVU107
 811:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 429               		.loc 1 811 13 is_stmt 0 view .LVU108
 430 00dc EBE5      		ldi r30,lo8(91)
 431 00de EC0F      		add r30,r28
 432 00e0 E330      		cpi r30,lo8(3)
 433 00e2 00F4      		brsh .L19
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 434               		.loc 1 812 9 is_stmt 1 view .LVU109
 435               	.LVL42:
 436               	.LBB39:
 437               	.LBI39:
 438               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  38:tmk_core/common/report.h **** enum mouse_buttons {
  39:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  40:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  41:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  42:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  43:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  44:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  45:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  46:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  47:tmk_core/common/report.h **** };
  48:tmk_core/common/report.h **** 
  49:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  50:tmk_core/common/report.h ****  *
  51:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  52:tmk_core/common/report.h ****  */
  53:tmk_core/common/report.h **** enum consumer_usages {
  54:tmk_core/common/report.h ****     // 15.5 Display Controls
  55:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  56:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  57:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  58:tmk_core/common/report.h ****     // 15.7 Transport Controls
  59:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  60:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  61:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  62:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  63:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  64:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  65:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  66:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  67:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  68:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  69:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  70:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  71:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  72:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  73:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  74:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  75:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  76:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  77:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  78:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  79:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  80:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  81:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  82:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  83:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  84:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  85:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  86:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  87:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  88:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  89:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  90:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  91:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  92:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  93:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  94:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  95:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  96:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  97:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  98:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  99:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 100:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 101:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 102:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 103:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 104:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 105:tmk_core/common/report.h **** };
 106:tmk_core/common/report.h **** 
 107:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 108:tmk_core/common/report.h ****  *
 109:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 110:tmk_core/common/report.h ****  */
 111:tmk_core/common/report.h **** enum desktop_usages {
 112:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 113:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 114:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 115:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 116:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 117:tmk_core/common/report.h ****     // 4.10 System Display Controls
 118:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 119:tmk_core/common/report.h **** };
 120:tmk_core/common/report.h **** 
 121:tmk_core/common/report.h **** // clang-format on
 122:tmk_core/common/report.h **** 
 123:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 124:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 125:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 126:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 127:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 128:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 129:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 130:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 131:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 132:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 133:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 134:tmk_core/common/report.h **** #    else
 135:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 136:tmk_core/common/report.h **** #    endif
 137:tmk_core/common/report.h **** #endif
 138:tmk_core/common/report.h **** 
 139:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 140:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 141:tmk_core/common/report.h **** #else
 142:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 143:tmk_core/common/report.h **** #endif
 144:tmk_core/common/report.h **** 
 145:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 146:tmk_core/common/report.h **** 
 147:tmk_core/common/report.h **** #ifdef __cplusplus
 148:tmk_core/common/report.h **** extern "C" {
 149:tmk_core/common/report.h **** #endif
 150:tmk_core/common/report.h **** 
 151:tmk_core/common/report.h **** /*
 152:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 153:tmk_core/common/report.h ****  *
 154:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 155:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 156:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 157:tmk_core/common/report.h ****  *
 158:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 159:tmk_core/common/report.h ****  *
 160:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 161:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 162:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 163:tmk_core/common/report.h ****  *
 164:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 165:tmk_core/common/report.h ****  *
 166:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 167:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 168:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 169:tmk_core/common/report.h ****  *
 170:tmk_core/common/report.h ****  */
 171:tmk_core/common/report.h **** typedef union {
 172:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 173:tmk_core/common/report.h ****     struct {
 174:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 175:tmk_core/common/report.h ****         uint8_t report_id;
 176:tmk_core/common/report.h **** #endif
 177:tmk_core/common/report.h ****         uint8_t mods;
 178:tmk_core/common/report.h ****         uint8_t reserved;
 179:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 180:tmk_core/common/report.h ****     };
 181:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 182:tmk_core/common/report.h ****     struct nkro_report {
 183:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 184:tmk_core/common/report.h ****         uint8_t report_id;
 185:tmk_core/common/report.h **** #    endif
 186:tmk_core/common/report.h ****         uint8_t mods;
 187:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 188:tmk_core/common/report.h ****     } nkro;
 189:tmk_core/common/report.h **** #endif
 190:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 191:tmk_core/common/report.h **** 
 192:tmk_core/common/report.h **** typedef struct {
 193:tmk_core/common/report.h ****     uint8_t  report_id;
 194:tmk_core/common/report.h ****     uint16_t usage;
 195:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 196:tmk_core/common/report.h **** 
 197:tmk_core/common/report.h **** typedef struct {
 198:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 199:tmk_core/common/report.h ****     uint8_t report_id;
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h ****     uint8_t buttons;
 202:tmk_core/common/report.h ****     int8_t  x;
 203:tmk_core/common/report.h ****     int8_t  y;
 204:tmk_core/common/report.h ****     int8_t  v;
 205:tmk_core/common/report.h ****     int8_t  h;
 206:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 207:tmk_core/common/report.h **** 
 208:tmk_core/common/report.h **** typedef struct {
 209:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 210:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 211:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 212:tmk_core/common/report.h **** #    else
 213:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 214:tmk_core/common/report.h **** #    endif
 215:tmk_core/common/report.h **** #endif
 216:tmk_core/common/report.h **** 
 217:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 218:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 219:tmk_core/common/report.h **** #endif
 220:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 221:tmk_core/common/report.h **** 
 222:tmk_core/common/report.h **** /* keycode to system usage */
 223:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 439               		.loc 3 223 24 view .LVU110
 440               	.LBE39:
 224:tmk_core/common/report.h ****     switch (key) {
 441               		.loc 3 224 5 view .LVU111
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 442               		.loc 1 812 9 is_stmt 0 view .LVU112
 443 00e4 F0E0      		ldi r31,0
 444 00e6 E050      		subi r30,lo8(-(CSWTCH.11))
 445 00e8 F040      		sbci r31,hi8(-(CSWTCH.11))
 446 00ea 8081      		ld r24,Z
 447 00ec 90E0      		ldi r25,0
 448               	/* epilogue start */
 449               		.loc 1 823 1 view .LVU113
 450 00ee CF91      		pop r28
 451               	.LVL43:
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 452               		.loc 1 812 9 view .LVU114
 453 00f0 0C94 0000 		jmp host_system_send
 454               	.LVL44:
 455               	.L19:
 813:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 456               		.loc 1 813 12 is_stmt 1 view .LVU115
 813:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 457               		.loc 1 813 15 is_stmt 0 view .LVU116
 458 00f4 E8E5      		ldi r30,lo8(88)
 459 00f6 EC0F      		add r30,r28
 460 00f8 E731      		cpi r30,lo8(23)
 461 00fa 00F4      		brsh .L20
 814:tmk_core/common/action.c ****     }
 462               		.loc 1 814 9 is_stmt 1 view .LVU117
 463               	.LVL45:
 464               	.LBB40:
 465               	.LBI40:
 225:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 226:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 227:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 228:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 229:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 230:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 231:tmk_core/common/report.h ****         default:
 232:tmk_core/common/report.h ****             return 0;
 233:tmk_core/common/report.h ****     }
 234:tmk_core/common/report.h **** }
 235:tmk_core/common/report.h **** 
 236:tmk_core/common/report.h **** /* keycode to consumer usage */
 237:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 466               		.loc 3 237 24 view .LVU118
 467               	.LBE40:
 238:tmk_core/common/report.h ****     switch (key) {
 468               		.loc 3 238 5 view .LVU119
 814:tmk_core/common/action.c ****     }
 469               		.loc 1 814 9 is_stmt 0 view .LVU120
 470 00fc F0E0      		ldi r31,0
 471 00fe EE0F      		lsl r30
 472 0100 FF1F      		rol r31
 473 0102 E050      		subi r30,lo8(-(CSWTCH.12))
 474 0104 F040      		sbci r31,hi8(-(CSWTCH.12))
 475 0106 8081      		ld r24,Z
 476 0108 9181      		ldd r25,Z+1
 477               	/* epilogue start */
 478               		.loc 1 823 1 view .LVU121
 479 010a CF91      		pop r28
 480               	.LVL46:
 814:tmk_core/common/action.c ****     }
 481               		.loc 1 814 9 view .LVU122
 482 010c 0C94 0000 		jmp host_consumer_send
 483               	.LVL47:
 484               	.L20:
 818:tmk_core/common/action.c ****         mousekey_on(code);
 485               		.loc 1 818 10 is_stmt 1 view .LVU123
 818:tmk_core/common/action.c ****         mousekey_on(code);
 486               		.loc 1 818 13 is_stmt 0 view .LVU124
 487 0110 CD3E      		cpi r28,lo8(-19)
 488 0112 00F0      		brlo .L9
 819:tmk_core/common/action.c ****         mousekey_send();
 489               		.loc 1 819 9 is_stmt 1 view .LVU125
 490 0114 8C2F      		mov r24,r28
 491 0116 0E94 0000 		call mousekey_on
 492               	.LVL48:
 820:tmk_core/common/action.c ****     }
 493               		.loc 1 820 9 view .LVU126
 494               	/* epilogue start */
 495               		.loc 1 823 1 is_stmt 0 view .LVU127
 496 011a CF91      		pop r28
 497               	.LVL49:
 820:tmk_core/common/action.c ****     }
 498               		.loc 1 820 9 view .LVU128
 499 011c 0C94 0000 		jmp mousekey_send
 500               	.LVL50:
 501               	.L9:
 502               	/* epilogue start */
 503               		.loc 1 823 1 view .LVU129
 504 0120 CF91      		pop r28
 505               	.LVL51:
 506               		.loc 1 823 1 view .LVU130
 507 0122 0895      		ret
 508               		.cfi_endproc
 509               	.LFE23:
 511               		.section	.text.unregister_code,"ax",@progbits
 512               	.global	unregister_code
 514               	unregister_code:
 515               	.LVL52:
 516               	.LFB24:
 824:tmk_core/common/action.c **** 
 825:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 826:tmk_core/common/action.c ****  *
 827:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 828:tmk_core/common/action.c ****  */
 829:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 517               		.loc 1 829 36 is_stmt 1 view -0
 518               		.cfi_startproc
 519               	/* prologue: function */
 520               	/* frame size = 0 */
 521               	/* stack size = 0 */
 522               	.L__stack_usage = 0
 830:tmk_core/common/action.c ****     if (code == KC_NO) {
 523               		.loc 1 830 5 view .LVU132
 524               		.loc 1 830 8 is_stmt 0 view .LVU133
 525 0000 8823      		tst r24
 526 0002 01F4      		brne .+2
 527 0004 00C0      		rjmp .L26
 831:tmk_core/common/action.c ****         return;
 832:tmk_core/common/action.c ****     }
 833:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 834:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 528               		.loc 1 834 10 is_stmt 1 view .LVU134
 529               		.loc 1 834 13 is_stmt 0 view .LVU135
 530 0006 8238      		cpi r24,lo8(-126)
 531 0008 01F4      		brne .L29
 835:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 836:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 837:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 532               		.loc 1 837 9 is_stmt 1 view .LVU136
 533               		.loc 1 837 15 is_stmt 0 view .LVU137
 534 000a 0E94 0000 		call host_keyboard_leds
 535               	.LVL53:
 536               		.loc 1 837 12 view .LVU138
 537 000e 81FF      		sbrs r24,1
 538 0010 00C0      		rjmp .L26
 838:tmk_core/common/action.c **** #    endif
 839:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 539               		.loc 1 839 9 is_stmt 1 view .LVU139
 540 0012 89E3      		ldi r24,lo8(57)
 541 0014 0E94 0000 		call add_key
 542               	.LVL54:
 840:tmk_core/common/action.c ****         send_keyboard_report();
 543               		.loc 1 840 9 view .LVU140
 544 0018 0E94 0000 		call send_keyboard_report
 545               	.LVL55:
 841:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 546               		.loc 1 841 9 view .LVU141
 547 001c 89E3      		ldi r24,lo8(57)
 548               	.L46:
 842:tmk_core/common/action.c ****         send_keyboard_report();
 843:tmk_core/common/action.c ****     }
 844:tmk_core/common/action.c **** 
 845:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 846:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 549               		.loc 1 851 9 is_stmt 0 view .LVU142
 550 001e 0E94 0000 		call del_key
 551               	.LVL56:
 552               	.L47:
 852:tmk_core/common/action.c ****         send_keyboard_report();
 553               		.loc 1 852 9 is_stmt 1 view .LVU143
 554 0022 0C94 0000 		jmp send_keyboard_report
 555               	.LVL57:
 556               	.L29:
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 557               		.loc 1 845 10 view .LVU144
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 558               		.loc 1 845 13 is_stmt 0 view .LVU145
 559 0026 8338      		cpi r24,lo8(-125)
 560 0028 01F4      		brne .L31
 847:tmk_core/common/action.c **** #    endif
 561               		.loc 1 847 9 is_stmt 1 view .LVU146
 847:tmk_core/common/action.c **** #    endif
 562               		.loc 1 847 15 is_stmt 0 view .LVU147
 563 002a 0E94 0000 		call host_keyboard_leds
 564               	.LVL58:
 847:tmk_core/common/action.c **** #    endif
 565               		.loc 1 847 12 view .LVU148
 566 002e 80FF      		sbrs r24,0
 567 0030 00C0      		rjmp .L26
 849:tmk_core/common/action.c ****         send_keyboard_report();
 568               		.loc 1 849 9 is_stmt 1 view .LVU149
 569 0032 83E5      		ldi r24,lo8(83)
 570 0034 0E94 0000 		call add_key
 571               	.LVL59:
 850:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 572               		.loc 1 850 9 view .LVU150
 573 0038 0E94 0000 		call send_keyboard_report
 574               	.LVL60:
 851:tmk_core/common/action.c ****         send_keyboard_report();
 575               		.loc 1 851 9 view .LVU151
 576 003c 83E5      		ldi r24,lo8(83)
 577 003e 00C0      		rjmp .L46
 578               	.LVL61:
 579               	.L31:
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 580               		.loc 1 855 10 view .LVU152
 581               		.loc 1 855 13 is_stmt 0 view .LVU153
 582 0040 8438      		cpi r24,lo8(-124)
 583 0042 01F4      		brne .L32
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 584               		.loc 1 857 9 is_stmt 1 view .LVU154
 585               		.loc 1 857 15 is_stmt 0 view .LVU155
 586 0044 0E94 0000 		call host_keyboard_leds
 587               	.LVL62:
 588               		.loc 1 857 12 view .LVU156
 589 0048 82FF      		sbrs r24,2
 590 004a 00C0      		rjmp .L26
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 591               		.loc 1 859 9 is_stmt 1 view .LVU157
 592 004c 87E4      		ldi r24,lo8(71)
 593 004e 0E94 0000 		call add_key
 594               	.LVL63:
 860:tmk_core/common/action.c ****         send_keyboard_report();
 595               		.loc 1 860 9 view .LVU158
 596 0052 0E94 0000 		call send_keyboard_report
 597               	.LVL64:
 861:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 598               		.loc 1 861 9 view .LVU159
 599 0056 87E4      		ldi r24,lo8(71)
 600 0058 00C0      		rjmp .L46
 601               	.LVL65:
 602               	.L32:
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** #endif
 865:tmk_core/common/action.c **** 
 866:tmk_core/common/action.c ****     else if IS_KEY (code) {
 603               		.loc 1 866 10 view .LVU160
 604               		.loc 1 866 13 is_stmt 0 view .LVU161
 605 005a 9CEF      		ldi r25,lo8(-4)
 606 005c 980F      		add r25,r24
 607 005e 913A      		cpi r25,lo8(-95)
 608 0060 00F0      		brlo .L46
 867:tmk_core/common/action.c ****         del_key(code);
 868:tmk_core/common/action.c ****         send_keyboard_report();
 869:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 609               		.loc 1 869 12 is_stmt 1 view .LVU162
 610               		.loc 1 869 15 is_stmt 0 view .LVU163
 611 0062 90E2      		ldi r25,lo8(32)
 612 0064 980F      		add r25,r24
 613 0066 9830      		cpi r25,lo8(8)
 614 0068 00F4      		brsh .L34
 870:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 615               		.loc 1 870 9 is_stmt 1 view .LVU164
 616               		.loc 1 870 18 is_stmt 0 view .LVU165
 617 006a 8770      		andi r24,lo8(7)
 618               	.LVL66:
 619               		.loc 1 870 9 view .LVU166
 620 006c 91E0      		ldi r25,lo8(1)
 621 006e 00C0      		rjmp 2f
 622               		1:
 623 0070 990F      		lsl r25
 624               		2:
 625 0072 8A95      		dec r24
 626 0074 02F4      		brpl 1b
 627 0076 892F      		mov r24,r25
 628 0078 0E94 0000 		call del_mods
 629               	.LVL67:
 871:tmk_core/common/action.c ****         send_keyboard_report();
 630               		.loc 1 871 9 is_stmt 1 view .LVU167
 631 007c 00C0      		rjmp .L47
 632               	.LVL68:
 633               	.L34:
 872:tmk_core/common/action.c ****     } else if IS_SYSTEM (code) {
 634               		.loc 1 872 12 view .LVU168
 635               		.loc 1 872 15 is_stmt 0 view .LVU169
 636 007e 9BE5      		ldi r25,lo8(91)
 637 0080 980F      		add r25,r24
 638 0082 9330      		cpi r25,lo8(3)
 639 0084 00F4      		brsh .L35
 873:tmk_core/common/action.c ****         host_system_send(0);
 640               		.loc 1 873 9 is_stmt 1 view .LVU170
 641 0086 90E0      		ldi r25,0
 642 0088 80E0      		ldi r24,0
 643               	.LVL69:
 644               		.loc 1 873 9 is_stmt 0 view .LVU171
 645 008a 0C94 0000 		jmp host_system_send
 646               	.LVL70:
 647               	.L35:
 874:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 648               		.loc 1 874 12 is_stmt 1 view .LVU172
 649               		.loc 1 874 15 is_stmt 0 view .LVU173
 650 008e 98E5      		ldi r25,lo8(88)
 651 0090 980F      		add r25,r24
 652 0092 9731      		cpi r25,lo8(23)
 653 0094 00F4      		brsh .L36
 875:tmk_core/common/action.c ****         host_consumer_send(0);
 654               		.loc 1 875 9 is_stmt 1 view .LVU174
 655 0096 90E0      		ldi r25,0
 656 0098 80E0      		ldi r24,0
 657               	.LVL71:
 658               		.loc 1 875 9 is_stmt 0 view .LVU175
 659 009a 0C94 0000 		jmp host_consumer_send
 660               	.LVL72:
 661               	.L36:
 876:tmk_core/common/action.c ****     }
 877:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 878:tmk_core/common/action.c ****     else if IS_MOUSEKEY (code) {
 662               		.loc 1 878 10 is_stmt 1 view .LVU176
 663               		.loc 1 878 13 is_stmt 0 view .LVU177
 664 009e 8D3E      		cpi r24,lo8(-19)
 665 00a0 00F0      		brlo .L26
 879:tmk_core/common/action.c ****         mousekey_off(code);
 666               		.loc 1 879 9 is_stmt 1 view .LVU178
 667 00a2 0E94 0000 		call mousekey_off
 668               	.LVL73:
 880:tmk_core/common/action.c ****         mousekey_send();
 669               		.loc 1 880 9 view .LVU179
 670 00a6 0C94 0000 		jmp mousekey_send
 671               	.LVL74:
 672               	.L26:
 673               	/* epilogue start */
 881:tmk_core/common/action.c ****     }
 882:tmk_core/common/action.c **** #endif
 883:tmk_core/common/action.c **** }
 674               		.loc 1 883 1 is_stmt 0 view .LVU180
 675 00aa 0895      		ret
 676               		.cfi_endproc
 677               	.LFE24:
 679               		.section	.text.tap_code_delay,"ax",@progbits
 680               	.global	tap_code_delay
 682               	tap_code_delay:
 683               	.LVL75:
 684               	.LFB25:
 884:tmk_core/common/action.c **** 
 885:tmk_core/common/action.c **** /** \brief Tap a keycode with a delay.
 886:tmk_core/common/action.c ****  *
 887:tmk_core/common/action.c ****  * \param code The basic keycode to tap.
 888:tmk_core/common/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 889:tmk_core/common/action.c ****  */
 890:tmk_core/common/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 685               		.loc 1 890 51 is_stmt 1 view -0
 686               		.cfi_startproc
 687               		.loc 1 890 51 is_stmt 0 view .LVU182
 688 0000 1F93      		push r17
 689               	.LCFI10:
 690               		.cfi_def_cfa_offset 3
 691               		.cfi_offset 17, -2
 692 0002 CF93      		push r28
 693               	.LCFI11:
 694               		.cfi_def_cfa_offset 4
 695               		.cfi_offset 28, -3
 696 0004 DF93      		push r29
 697               	.LCFI12:
 698               		.cfi_def_cfa_offset 5
 699               		.cfi_offset 29, -4
 700               	/* prologue: function */
 701               	/* frame size = 0 */
 702               	/* stack size = 3 */
 703               	.L__stack_usage = 3
 704 0006 182F      		mov r17,r24
 705 0008 EB01      		movw r28,r22
 891:tmk_core/common/action.c ****     register_code(code);
 706               		.loc 1 891 5 is_stmt 1 view .LVU183
 707 000a 0E94 0000 		call register_code
 708               	.LVL76:
 892:tmk_core/common/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 709               		.loc 1 892 5 view .LVU184
 710               	.LBB41:
 711               		.loc 1 892 10 view .LVU185
 712               	.L49:
 713               		.loc 1 892 30 discriminator 1 view .LVU186
 714               		.loc 1 892 5 is_stmt 0 discriminator 1 view .LVU187
 715 000e 2097      		sbiw r28,0
 716 0010 01F4      		brne .L50
 717               		.loc 1 892 5 discriminator 1 view .LVU188
 718               	.LBE41:
 893:tmk_core/common/action.c ****         wait_ms(1);
 894:tmk_core/common/action.c ****     }
 895:tmk_core/common/action.c ****     unregister_code(code);
 719               		.loc 1 895 5 is_stmt 1 view .LVU189
 720 0012 812F      		mov r24,r17
 721               	/* epilogue start */
 896:tmk_core/common/action.c **** }
 722               		.loc 1 896 1 is_stmt 0 view .LVU190
 723 0014 DF91      		pop r29
 724 0016 CF91      		pop r28
 725               	.LVL77:
 726               		.loc 1 896 1 view .LVU191
 727 0018 1F91      		pop r17
 728               	.LVL78:
 895:tmk_core/common/action.c **** }
 729               		.loc 1 895 5 view .LVU192
 730 001a 0C94 0000 		jmp unregister_code
 731               	.LVL79:
 732               	.L50:
 733               	.LBB44:
 893:tmk_core/common/action.c ****         wait_ms(1);
 734               		.loc 1 893 9 is_stmt 1 view .LVU193
 735               	.LBB42:
 736               	.LBI42:
 166:c:\qmk_msys\mingw64\avr\include\util\delay.h **** {
 737               		.loc 2 166 1 view .LVU194
 738               	.LBB43:
 168:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 739               		.loc 2 168 2 view .LVU195
 172:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 740               		.loc 2 172 2 view .LVU196
 173:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 741               		.loc 2 173 2 view .LVU197
 174:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 742               		.loc 2 174 2 view .LVU198
 184:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 743               		.loc 2 184 3 view .LVU199
 744               		.loc 2 187 2 view .LVU200
 745 001e 8FE9      		ldi r24,lo8(3999)
 746 0020 9FE0      		ldi r25,hi8(3999)
 747 0022 0197      	1:	sbiw r24,1
 748 0024 01F4      		brne 1b
 749 0026 00C0      		rjmp .
 750 0028 0000      		nop
 751               	.LVL80:
 752               		.loc 2 187 2 is_stmt 0 view .LVU201
 753               	.LBE43:
 754               	.LBE42:
 892:tmk_core/common/action.c ****         wait_ms(1);
 755               		.loc 1 892 37 is_stmt 1 view .LVU202
 892:tmk_core/common/action.c ****         wait_ms(1);
 756               		.loc 1 892 38 is_stmt 0 view .LVU203
 757 002a 2197      		sbiw r28,1
 758               	.LVL81:
 892:tmk_core/common/action.c ****         wait_ms(1);
 759               		.loc 1 892 38 view .LVU204
 760 002c 00C0      		rjmp .L49
 761               	.LBE44:
 762               		.cfi_endproc
 763               	.LFE25:
 765               		.section	.text.tap_code,"ax",@progbits
 766               	.global	tap_code
 768               	tap_code:
 769               	.LVL82:
 770               	.LFB26:
 897:tmk_core/common/action.c **** 
 898:tmk_core/common/action.c **** /** \brief Tap a keycode with the default delay.
 899:tmk_core/common/action.c ****  *
 900:tmk_core/common/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 901:tmk_core/common/action.c ****  */
 902:tmk_core/common/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 771               		.loc 1 902 29 is_stmt 1 view -0
 772               		.cfi_startproc
 773               	/* prologue: function */
 774               	/* frame size = 0 */
 775               	/* stack size = 0 */
 776               	.L__stack_usage = 0
 777               		.loc 1 902 31 view .LVU206
 778 0000 70E0      		ldi r23,0
 779 0002 60E0      		ldi r22,0
 780 0004 8933      		cpi r24,lo8(57)
 781 0006 01F4      		brne .L52
 782 0008 60E5      		ldi r22,lo8(80)
 783 000a 70E0      		ldi r23,0
 784               	.L52:
 785               		.loc 1 902 31 is_stmt 0 discriminator 4 view .LVU207
 786 000c 0C94 0000 		jmp tap_code_delay
 787               	.LVL83:
 788               		.loc 1 902 31 discriminator 4 view .LVU208
 789               		.cfi_endproc
 790               	.LFE26:
 792               		.section	.text.register_mods,"ax",@progbits
 793               	.global	register_mods
 795               	register_mods:
 796               	.LVL84:
 797               	.LFB27:
 903:tmk_core/common/action.c **** 
 904:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 905:tmk_core/common/action.c ****  *
 906:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 907:tmk_core/common/action.c ****  */
 908:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 798               		.loc 1 908 34 is_stmt 1 view -0
 799               		.cfi_startproc
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 0 */
 803               	.L__stack_usage = 0
 909:tmk_core/common/action.c ****     if (mods) {
 804               		.loc 1 909 5 view .LVU210
 805               		.loc 1 909 8 is_stmt 0 view .LVU211
 806 0000 8823      		tst r24
 807 0002 01F0      		breq .L54
 910:tmk_core/common/action.c ****         add_mods(mods);
 808               		.loc 1 910 9 is_stmt 1 view .LVU212
 809 0004 0E94 0000 		call add_mods
 810               	.LVL85:
 911:tmk_core/common/action.c ****         send_keyboard_report();
 811               		.loc 1 911 9 view .LVU213
 812 0008 0C94 0000 		jmp send_keyboard_report
 813               	.LVL86:
 814               	.L54:
 815               	/* epilogue start */
 912:tmk_core/common/action.c ****     }
 913:tmk_core/common/action.c **** }
 816               		.loc 1 913 1 is_stmt 0 view .LVU214
 817 000c 0895      		ret
 818               		.cfi_endproc
 819               	.LFE27:
 821               		.section	.text.unregister_mods,"ax",@progbits
 822               	.global	unregister_mods
 824               	unregister_mods:
 825               	.LVL87:
 826               	.LFB28:
 914:tmk_core/common/action.c **** 
 915:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 916:tmk_core/common/action.c ****  *
 917:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 918:tmk_core/common/action.c ****  */
 919:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 827               		.loc 1 919 36 is_stmt 1 view -0
 828               		.cfi_startproc
 829               	/* prologue: function */
 830               	/* frame size = 0 */
 831               	/* stack size = 0 */
 832               	.L__stack_usage = 0
 920:tmk_core/common/action.c ****     if (mods) {
 833               		.loc 1 920 5 view .LVU216
 834               		.loc 1 920 8 is_stmt 0 view .LVU217
 835 0000 8823      		tst r24
 836 0002 01F0      		breq .L56
 921:tmk_core/common/action.c ****         del_mods(mods);
 837               		.loc 1 921 9 is_stmt 1 view .LVU218
 838 0004 0E94 0000 		call del_mods
 839               	.LVL88:
 922:tmk_core/common/action.c ****         send_keyboard_report();
 840               		.loc 1 922 9 view .LVU219
 841 0008 0C94 0000 		jmp send_keyboard_report
 842               	.LVL89:
 843               	.L56:
 844               	/* epilogue start */
 923:tmk_core/common/action.c ****     }
 924:tmk_core/common/action.c **** }
 845               		.loc 1 924 1 is_stmt 0 view .LVU220
 846 000c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               		.section	.text.process_action,"ax",@progbits
 851               	.global	process_action
 853               	process_action:
 854               	.LVL90:
 855               	.LFB22:
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 856               		.loc 1 240 59 is_stmt 1 view -0
 857               		.cfi_startproc
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 858               		.loc 1 240 59 is_stmt 0 view .LVU222
 859 0000 BF92      		push r11
 860               	.LCFI13:
 861               		.cfi_def_cfa_offset 3
 862               		.cfi_offset 11, -2
 863 0002 CF92      		push r12
 864               	.LCFI14:
 865               		.cfi_def_cfa_offset 4
 866               		.cfi_offset 12, -3
 867 0004 DF92      		push r13
 868               	.LCFI15:
 869               		.cfi_def_cfa_offset 5
 870               		.cfi_offset 13, -4
 871 0006 EF92      		push r14
 872               	.LCFI16:
 873               		.cfi_def_cfa_offset 6
 874               		.cfi_offset 14, -5
 875 0008 FF92      		push r15
 876               	.LCFI17:
 877               		.cfi_def_cfa_offset 7
 878               		.cfi_offset 15, -6
 879 000a 0F93      		push r16
 880               	.LCFI18:
 881               		.cfi_def_cfa_offset 8
 882               		.cfi_offset 16, -7
 883 000c 1F93      		push r17
 884               	.LCFI19:
 885               		.cfi_def_cfa_offset 9
 886               		.cfi_offset 17, -8
 887 000e CF93      		push r28
 888               	.LCFI20:
 889               		.cfi_def_cfa_offset 10
 890               		.cfi_offset 28, -9
 891 0010 DF93      		push r29
 892               	.LCFI21:
 893               		.cfi_def_cfa_offset 11
 894               		.cfi_offset 29, -10
 895               	/* prologue: function */
 896               	/* frame size = 0 */
 897               	/* stack size = 9 */
 898               	.L__stack_usage = 9
 899 0012 6C01      		movw r12,r24
 900 0014 D62F      		mov r29,r22
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 901               		.loc 1 240 59 view .LVU223
 902 0016 C72F      		mov r28,r23
 241:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 903               		.loc 1 241 5 is_stmt 1 view .LVU224
 241:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 904               		.loc 1 241 16 is_stmt 0 view .LVU225
 905 0018 FC01      		movw r30,r24
 906 001a 1281      		ldd r17,Z+2
 907               	.LVL91:
 243:tmk_core/common/action.c **** #endif
 908               		.loc 1 243 5 is_stmt 1 view .LVU226
 243:tmk_core/common/action.c **** #endif
 909               		.loc 1 243 36 is_stmt 0 view .LVU227
 910 001c 0581      		ldd r16,Z+5
 911 001e 0295      		swap r16
 912 0020 0F70      		andi r16,lo8(15)
 913               	.LVL92:
 247:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 914               		.loc 1 247 5 is_stmt 1 view .LVU228
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 915               		.loc 1 249 5 view .LVU229
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 916               		.loc 1 249 9 is_stmt 0 view .LVU230
 917 0022 0E94 0000 		call is_oneshot_layer_active
 918               	.LVL93:
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 919               		.loc 1 249 9 view .LVU231
 920 0026 E82E      		mov r14,r24
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 921               		.loc 1 249 8 view .LVU232
 922 0028 8823      		tst r24
 923 002a 01F0      		breq .L59
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 924               		.loc 1 249 43 discriminator 1 view .LVU233
 925 002c E12E      		mov r14,r17
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 926               		.loc 1 249 35 discriminator 1 view .LVU234
 927 002e 1123      		tst r17
 928 0030 01F0      		breq .L59
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 929               		.loc 1 249 71 discriminator 2 view .LVU235
 930 0032 8C2F      		mov r24,r28
 931 0034 807F      		andi r24,lo8(-16)
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 932               		.loc 1 249 52 discriminator 2 view .LVU236
 933 0036 8034      		cpi r24,lo8(64)
 934 0038 01F0      		breq .L60
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 935               		.loc 1 249 87 discriminator 3 view .LVU237
 936 003a 80E2      		ldi r24,lo8(32)
 937               	.LVL94:
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 938               		.loc 1 249 87 discriminator 3 view .LVU238
 939 003c 8D0F      		add r24,r29
 247:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 940               		.loc 1 247 10 discriminator 3 view .LVU239
 941 003e E12C      		mov r14,__zero_reg__
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 942               		.loc 1 249 84 discriminator 3 view .LVU240
 943 0040 8830      		cpi r24,lo8(8)
 944 0042 00F0      		brlo .L59
 945               	.L60:
 254:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 946               		.loc 1 254 9 is_stmt 1 view .LVU241
 947 0044 82E0      		ldi r24,lo8(2)
 948 0046 0E94 0000 		call clear_oneshot_layer_state
 949               	.LVL95:
 255:tmk_core/common/action.c ****     }
 950               		.loc 1 255 9 view .LVU242
 255:tmk_core/common/action.c ****     }
 951               		.loc 1 255 31 is_stmt 0 view .LVU243
 952 004a 0E94 0000 		call is_oneshot_layer_active
 953               	.LVL96:
 255:tmk_core/common/action.c ****     }
 954               		.loc 1 255 9 view .LVU244
 955 004e 91E0      		ldi r25,lo8(1)
 956 0050 E82E      		mov r14,r24
 957 0052 E926      		eor r14,r25
 958               	.LVL97:
 959               	.L59:
 259:tmk_core/common/action.c ****         /* Key and Mods */
 960               		.loc 1 259 5 is_stmt 1 view .LVU245
 259:tmk_core/common/action.c ****         /* Key and Mods */
 961               		.loc 1 259 24 is_stmt 0 view .LVU246
 962 0054 BC2E      		mov r11,r28
 963 0056 B294      		swap r11
 964 0058 9FE0      		ldi r25,lo8(15)
 965 005a B922      		and r11,r25
 259:tmk_core/common/action.c ****         /* Key and Mods */
 966               		.loc 1 259 5 view .LVU247
 967 005c EB2D      		mov r30,r11
 968 005e F0E0      		ldi r31,0
 969 0060 E050      		subi r30,lo8(-(gs(.L63)))
 970 0062 F040      		sbci r31,hi8(-(gs(.L63)))
 971 0064 0C94 0000 		jmp __tablejump2__
 972               		.section	.jumptables.gcc.process_action,"a",@progbits
 973               		.p2align	1
 974               	.L63:
 975 0000 0000      		.word gs(.L71)
 976 0002 0000      		.word gs(.L71)
 977 0004 0000      		.word gs(.L70)
 978 0006 0000      		.word gs(.L70)
 979 0008 0000      		.word gs(.L69)
 980 000a 0000      		.word gs(.L68)
 981 000c 0000      		.word gs(.L61)
 982 000e 0000      		.word gs(.L61)
 983 0010 0000      		.word gs(.L67)
 984 0012 0000      		.word gs(.L66)
 985 0014 0000      		.word gs(.L65)
 986 0016 0000      		.word gs(.L65)
 987 0018 0000      		.word gs(.L64)
 988 001a 0000      		.word gs(.L61)
 989 001c 0000      		.word gs(.L61)
 990 001e 0000      		.word gs(.L62)
 991               		.section	.text.process_action
 992               	.L71:
 993               	.LBB45:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 994               		.loc 1 263 13 is_stmt 1 view .LVU248
 995 0068 0C2F      		mov r16,r28
 996               	.LVL98:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 997               		.loc 1 263 13 is_stmt 0 view .LVU249
 998 006a 0F70      		andi r16,lo8(15)
 263:tmk_core/common/action.c ****             if (event.pressed) {
 999               		.loc 1 263 44 view .LVU250
 1000 006c C07F      		andi r28,lo8(-16)
 1001               	.LVL99:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1002               		.loc 1 263 21 view .LVU251
 1003 006e 01F0      		breq .L72
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1004               		.loc 1 263 21 discriminator 2 view .LVU252
 1005 0070 0295      		swap r16
 1006 0072 007F      		andi r16,lo8(-16)
 1007               	.L72:
 1008               	.LVL100:
 264:tmk_core/common/action.c ****                 if (mods) {
 1009               		.loc 1 264 13 is_stmt 1 discriminator 4 view .LVU253
 264:tmk_core/common/action.c ****                 if (mods) {
 1010               		.loc 1 264 16 is_stmt 0 discriminator 4 view .LVU254
 1011 0074 1123      		tst r17
 1012 0076 01F0      		breq .L73
 265:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1013               		.loc 1 265 17 is_stmt 1 view .LVU255
 265:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1014               		.loc 1 265 20 is_stmt 0 view .LVU256
 1015 0078 0023      		tst r16
 1016 007a 01F0      		breq .L170
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1017               		.loc 1 266 21 is_stmt 1 view .LVU257
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1018               		.loc 1 266 25 is_stmt 0 view .LVU258
 1019 007c 80E2      		ldi r24,lo8(32)
 1020 007e 8D0F      		add r24,r29
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1021               		.loc 1 266 24 view .LVU259
 1022 0080 8830      		cpi r24,lo8(8)
 1023 0082 00F0      		brlo .L75
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1024               		.loc 1 266 49 discriminator 1 view .LVU260
 1025 0084 D111      		cpse r29,__zero_reg__
 1026 0086 00C0      		rjmp .L76
 1027               	.L75:
 270:tmk_core/common/action.c ****                     } else {
 1028               		.loc 1 270 25 is_stmt 1 view .LVU261
 1029 0088 802F      		mov r24,r16
 1030 008a 0E94 0000 		call add_mods
 1031               	.LVL101:
 1032               	.L77:
 274:tmk_core/common/action.c ****                 }
 1033               		.loc 1 274 21 view .LVU262
 1034 008e 0E94 0000 		call send_keyboard_report
 1035               	.LVL102:
 276:tmk_core/common/action.c ****             } else {
 1036               		.loc 1 276 17 view .LVU263
 1037               	.L170:
 276:tmk_core/common/action.c ****             } else {
 1038               		.loc 1 276 17 is_stmt 0 view .LVU264
 1039               	.LBE45:
 555:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1040               		.loc 1 555 75 is_stmt 1 view .LVU265
 556:tmk_core/common/action.c ****                         } else {
 1041               		.loc 1 556 29 view .LVU266
 1042 0092 8D2F      		mov r24,r29
 1043 0094 0E94 0000 		call register_code
 1044               	.LVL103:
 1045 0098 00C0      		rjmp .L61
 1046               	.LVL104:
 1047               	.L76:
 1048               	.LBB46:
 272:tmk_core/common/action.c ****                     }
 1049               		.loc 1 272 25 view .LVU267
 1050 009a 802F      		mov r24,r16
 1051 009c 0E94 0000 		call add_weak_mods
 1052               	.LVL105:
 1053 00a0 00C0      		rjmp .L77
 1054               	.L73:
 278:tmk_core/common/action.c ****                 if (mods) {
 1055               		.loc 1 278 17 view .LVU268
 1056 00a2 8D2F      		mov r24,r29
 1057 00a4 0E94 0000 		call unregister_code
 1058               	.LVL106:
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1059               		.loc 1 279 17 view .LVU269
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1060               		.loc 1 279 20 is_stmt 0 view .LVU270
 1061 00a8 0023      		tst r16
 1062 00aa 01F0      		breq .L61
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1063               		.loc 1 280 21 is_stmt 1 view .LVU271
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1064               		.loc 1 280 25 is_stmt 0 view .LVU272
 1065 00ac 80E2      		ldi r24,lo8(32)
 1066 00ae 8D0F      		add r24,r29
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1067               		.loc 1 280 24 view .LVU273
 1068 00b0 8830      		cpi r24,lo8(8)
 1069 00b2 00F0      		brlo .L79
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1070               		.loc 1 280 49 discriminator 1 view .LVU274
 1071 00b4 D111      		cpse r29,__zero_reg__
 1072 00b6 00C0      		rjmp .L80
 1073               	.L79:
 281:tmk_core/common/action.c ****                     } else {
 1074               		.loc 1 281 25 is_stmt 1 view .LVU275
 1075 00b8 802F      		mov r24,r16
 1076 00ba 0E94 0000 		call del_mods
 1077               	.LVL107:
 1078               	.L81:
 285:tmk_core/common/action.c ****                 }
 1079               		.loc 1 285 21 view .LVU276
 1080 00be 0E94 0000 		call send_keyboard_report
 1081               	.LVL108:
 1082               	.L61:
 285:tmk_core/common/action.c ****                 }
 1083               		.loc 1 285 21 is_stmt 0 view .LVU277
 1084               	.LBE46:
 670:tmk_core/common/action.c ****         case ACT_LAYER:
 1085               		.loc 1 670 5 is_stmt 1 view .LVU278
 1086 00c2 2B2D      		mov r18,r11
 1087 00c4 2850      		subi r18,8
 1088 00c6 330B      		sbc r19,r19
 1089 00c8 2430      		cpi r18,4
 1090 00ca 3105      		cpc r19,__zero_reg__
 1091 00cc 00F4      		brsh .L134
 677:tmk_core/common/action.c ****             break;
 1092               		.loc 1 677 13 view .LVU279
 1093 00ce 0E94 0000 		call host_keyboard_leds
 1094               	.LVL109:
 1095 00d2 0E94 0000 		call led_set
 1096               	.LVL110:
 678:tmk_core/common/action.c ****         default:
 1097               		.loc 1 678 13 view .LVU280
 1098               	.L134:
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1099               		.loc 1 723 5 view .LVU281
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1100               		.loc 1 723 8 is_stmt 0 view .LVU282
 1101 00d6 EE20      		tst r14
 1102 00d8 01F4      		brne .+2
 1103 00da 00C0      		rjmp .L58
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1104               		.loc 1 723 33 discriminator 1 view .LVU283
 1105 00dc 0E94 0000 		call get_oneshot_layer_state
 1106               	.LVL111:
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1107               		.loc 1 723 28 discriminator 1 view .LVU284
 1108 00e0 80FD      		sbrc r24,0
 1109 00e2 00C0      		rjmp .L58
 724:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1110               		.loc 1 724 9 is_stmt 1 view .LVU285
 724:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1111               		.loc 1 724 31 is_stmt 0 view .LVU286
 1112 00e4 F601      		movw r30,r12
 1113 00e6 1282      		std Z+2,__zero_reg__
 725:tmk_core/common/action.c ****         process_record(record);
 1114               		.loc 1 725 9 is_stmt 1 view .LVU287
 1115 00e8 0E94 0000 		call get_oneshot_layer
 1116               	.LVL112:
 1117 00ec 0E94 0000 		call layer_on
 1118               	.LVL113:
 726:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1119               		.loc 1 726 9 view .LVU288
 1120 00f0 C601      		movw r24,r12
 1121 00f2 0E94 0000 		call process_record
 1122               	.LVL114:
 727:tmk_core/common/action.c ****     }
 1123               		.loc 1 727 9 view .LVU289
 1124 00f6 0E94 0000 		call get_oneshot_layer
 1125               	.LVL115:
 1126               	/* epilogue start */
 730:tmk_core/common/action.c **** 
 1127               		.loc 1 730 1 is_stmt 0 view .LVU290
 1128 00fa DF91      		pop r29
 1129               	.LVL116:
 730:tmk_core/common/action.c **** 
 1130               		.loc 1 730 1 view .LVU291
 1131 00fc CF91      		pop r28
 730:tmk_core/common/action.c **** 
 1132               		.loc 1 730 1 view .LVU292
 1133 00fe 1F91      		pop r17
 1134 0100 0F91      		pop r16
 1135 0102 FF90      		pop r15
 1136 0104 EF90      		pop r14
 1137               	.LVL117:
 730:tmk_core/common/action.c **** 
 1138               		.loc 1 730 1 view .LVU293
 1139 0106 DF90      		pop r13
 1140 0108 CF90      		pop r12
 1141               	.LVL118:
 730:tmk_core/common/action.c **** 
 1142               		.loc 1 730 1 view .LVU294
 1143 010a BF90      		pop r11
 727:tmk_core/common/action.c ****     }
 1144               		.loc 1 727 9 view .LVU295
 1145 010c 0C94 0000 		jmp layer_off
 1146               	.LVL119:
 1147               	.L80:
 1148               	.LBB47:
 283:tmk_core/common/action.c ****                     }
 1149               		.loc 1 283 25 is_stmt 1 view .LVU296
 1150 0110 802F      		mov r24,r16
 1151 0112 0E94 0000 		call del_weak_mods
 1152               	.LVL120:
 1153 0116 00C0      		rjmp .L81
 1154               	.LVL121:
 1155               	.L70:
 283:tmk_core/common/action.c ****                     }
 1156               		.loc 1 283 25 is_stmt 0 view .LVU297
 1157               	.LBE47:
 1158               	.LBB48:
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1159               		.loc 1 292 13 is_stmt 1 view .LVU298
 1160 0118 FC2F      		mov r31,r28
 1161 011a FF70      		andi r31,lo8(15)
 1162 011c FF2E      		mov r15,r31
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1163               		.loc 1 292 44 is_stmt 0 view .LVU299
 1164 011e C07F      		andi r28,lo8(-16)
 1165               	.LVL122:
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1166               		.loc 1 292 21 view .LVU300
 1167 0120 C032      		cpi r28,lo8(32)
 1168 0122 01F0      		breq .L82
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1169               		.loc 1 292 21 discriminator 2 view .LVU301
 1170 0124 F294      		swap r15
 1171 0126 80EF      		ldi r24,lo8(-16)
 1172 0128 F822      		and r15,r24
 1173               	.L82:
 1174               	.LVL123:
 293:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1175               		.loc 1 293 13 is_stmt 1 discriminator 4 view .LVU302
 1176 012a DD23      		tst r29
 1177 012c 01F0      		breq .L83
 1178 012e D130      		cpi r29,lo8(1)
 1179 0130 01F0      		breq .L84
 348:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1180               		.loc 1 348 21 view .LVU303
 348:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1181               		.loc 1 348 24 is_stmt 0 view .LVU304
 1182 0132 1123      		tst r17
 1183 0134 01F0      		breq .L92
 349:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1184               		.loc 1 349 25 is_stmt 1 view .LVU305
 349:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1185               		.loc 1 349 28 is_stmt 0 view .LVU306
 1186 0136 0023      		tst r16
 1187 0138 01F0      		breq .L93
 351:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1188               		.loc 1 351 29 is_stmt 1 view .LVU307
 355:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1189               		.loc 1 355 33 is_stmt 0 view .LVU308
 1190 013a F601      		movw r30,r12
 1191 013c 8581      		ldd r24,Z+5
 351:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1192               		.loc 1 351 32 view .LVU309
 1193 013e 80FF      		sbrs r24,0
 1194 0140 00C0      		rjmp .L170
 356:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1195               		.loc 1 356 76 is_stmt 1 view .LVU310
 358:tmk_core/common/action.c ****                                 register_mods(mods);
 1196               		.loc 1 358 33 view .LVU311
 358:tmk_core/common/action.c ****                                 register_mods(mods);
 1197               		.loc 1 358 51 is_stmt 0 view .LVU312
 1198 0142 8F70      		andi r24,lo8(15)
 1199 0144 8583      		std Z+5,r24
 359:tmk_core/common/action.c ****                             } else
 1200               		.loc 1 359 33 is_stmt 1 view .LVU313
 1201 0146 00C0      		rjmp .L93
 1202               	.L83:
 297:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1203               		.loc 1 297 21 view .LVU314
 297:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1204               		.loc 1 297 24 is_stmt 0 view .LVU315
 1205 0148 1123      		tst r17
 1206 014a 01F0      		breq .L86
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1207               		.loc 1 298 25 is_stmt 1 view .LVU316
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1208               		.loc 1 298 28 is_stmt 0 view .LVU317
 1209 014c 0111      		cpse r16,__zero_reg__
 1210 014e 00C0      		rjmp .L87
 1211               	.L88:
 312:tmk_core/common/action.c ****                         }
 1212               		.loc 1 312 29 is_stmt 1 view .LVU318
 312:tmk_core/common/action.c ****                         }
 1213               		.loc 1 312 50 is_stmt 0 view .LVU319
 1214 0150 0E94 0000 		call get_oneshot_mods
 1215               	.LVL124:
 312:tmk_core/common/action.c ****                         }
 1216               		.loc 1 312 29 view .LVU320
 1217 0154 8F29      		or r24,r15
 1218               	.LVL125:
 1219               	.L169:
 312:tmk_core/common/action.c ****                         }
 1220               		.loc 1 312 29 view .LVU321
 1221               	.LBE48:
 482:tmk_core/common/action.c ****             } else {
 1222               		.loc 1 482 17 view .LVU322
 1223 0156 0E94 0000 		call register_mods
 1224               	.LVL126:
 1225 015a 00C0      		rjmp .L61
 1226               	.LVL127:
 1227               	.L87:
 1228               	.LBB51:
 301:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1229               		.loc 1 301 32 is_stmt 1 view .LVU323
 301:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1230               		.loc 1 301 35 is_stmt 0 view .LVU324
 1231 015c 0130      		cpi r16,lo8(1)
 1232 015e 01F4      		brne .L88
 302:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1233               		.loc 1 302 65 is_stmt 1 view .LVU325
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1234               		.loc 1 303 29 view .LVU326
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1235               		.loc 1 303 53 is_stmt 0 view .LVU327
 1236 0160 0E94 0000 		call get_oneshot_mods
 1237               	.LVL128:
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1238               		.loc 1 303 29 view .LVU328
 1239 0164 8F29      		or r24,r15
 1240 0166 0E94 0000 		call set_oneshot_mods
 1241               	.LVL129:
 1242 016a 00C0      		rjmp .L61
 1243               	.L86:
 315:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1244               		.loc 1 315 25 is_stmt 1 view .LVU329
 315:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1245               		.loc 1 315 28 is_stmt 0 view .LVU330
 1246 016c 0111      		cpse r16,__zero_reg__
 1247 016e 00C0      		rjmp .L89
 1248               	.L172:
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 1249               		.loc 1 330 29 is_stmt 1 view .LVU331
 1250 0170 0E94 0000 		call clear_oneshot_mods
 1251               	.LVL130:
 331:tmk_core/common/action.c ****                         }
 1252               		.loc 1 331 29 view .LVU332
 1253               	.L95:
 380:tmk_core/common/action.c ****                             unregister_mods(mods);
 1254               		.loc 1 380 67 view .LVU333
 381:tmk_core/common/action.c ****                         }
 1255               		.loc 1 381 29 view .LVU334
 1256 0174 8F2D      		mov r24,r15
 1257 0176 0E94 0000 		call unregister_mods
 1258               	.LVL131:
 1259 017a 00C0      		rjmp .L61
 1260               	.L89:
 318:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1261               		.loc 1 318 32 view .LVU335
 318:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1262               		.loc 1 318 35 is_stmt 0 view .LVU336
 1263 017c 0130      		cpi r16,lo8(1)
 1264 017e 01F4      		brne .+2
 1265 0180 00C0      		rjmp .L61
 1266 0182 00C0      		rjmp .L172
 1267               	.L84:
 337:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1268               		.loc 1 337 21 is_stmt 1 view .LVU337
 337:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1269               		.loc 1 337 24 is_stmt 0 view .LVU338
 1270 0184 1123      		tst r17
 1271 0186 01F0      		breq .L91
 338:tmk_core/common/action.c ****                             register_mods(mods);
 1272               		.loc 1 338 25 is_stmt 1 view .LVU339
 338:tmk_core/common/action.c ****                             register_mods(mods);
 1273               		.loc 1 338 28 is_stmt 0 view .LVU340
 1274 0188 0630      		cpi r16,lo8(6)
 1275 018a 00F0      		brlo .+2
 1276 018c 00C0      		rjmp .L61
 1277               	.L93:
 367:tmk_core/common/action.c ****                             register_mods(mods);
 1278               		.loc 1 367 67 is_stmt 1 view .LVU341
 368:tmk_core/common/action.c ****                         }
 1279               		.loc 1 368 29 view .LVU342
 1280 018e 8F2D      		mov r24,r15
 1281 0190 00C0      		rjmp .L169
 1282               	.L91:
 342:tmk_core/common/action.c ****                             unregister_mods(mods);
 1283               		.loc 1 342 25 view .LVU343
 342:tmk_core/common/action.c ****                             unregister_mods(mods);
 1284               		.loc 1 342 28 is_stmt 0 view .LVU344
 1285 0192 0530      		cpi r16,lo8(5)
 1286 0194 00F0      		brlo .+2
 1287 0196 00C0      		rjmp .L61
 1288 0198 00C0      		rjmp .L95
 1289               	.L92:
 371:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1290               		.loc 1 371 25 is_stmt 1 view .LVU345
 371:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1291               		.loc 1 371 28 is_stmt 0 view .LVU346
 1292 019a 0023      		tst r16
 1293 019c 01F0      		breq .L95
 372:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1294               		.loc 1 372 71 is_stmt 1 view .LVU347
 373:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1295               		.loc 1 373 29 view .LVU348
 373:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1296               		.loc 1 373 32 is_stmt 0 view .LVU349
 1297 019e D933      		cpi r29,lo8(57)
 1298 01a0 01F4      		brne .L133
 374:tmk_core/common/action.c ****                             } else {
 1299               		.loc 1 374 33 is_stmt 1 view .LVU350
 1300               	.LVL132:
 1301               	.LBB49:
 1302               	.LBI49:
 166:c:\qmk_msys\mingw64\avr\include\util\delay.h **** {
 1303               		.loc 2 166 1 view .LVU351
 1304               	.LBB50:
 168:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1305               		.loc 2 168 2 view .LVU352
 172:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1306               		.loc 2 172 2 view .LVU353
 173:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1307               		.loc 2 173 2 view .LVU354
 174:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 1308               		.loc 2 174 2 view .LVU355
 184:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 1309               		.loc 2 184 3 view .LVU356
 1310               		.loc 2 187 2 view .LVU357
 1311 01a2 FFEF      		ldi r31,lo8(255999)
 1312 01a4 27EE      		ldi r18,hi8(255999)
 1313 01a6 33E0      		ldi r19,hlo8(255999)
 1314 01a8 F150      	1:	subi r31,1
 1315 01aa 2040      		sbci r18,0
 1316 01ac 3040      		sbci r19,0
 1317 01ae 01F4      		brne 1b
 1318               	.LVL133:
 1319               	.L173:
 1320               		.loc 2 187 2 is_stmt 0 view .LVU358
 1321               	.LBE50:
 1322               	.LBE49:
 1323               	.LBE51:
 1324               	.LBB52:
 1325               	.LBB53:
 1326 01b0 00C0      		rjmp .
 1327 01b2 0000      		nop
 1328               	.L133:
 1329               	.LBE53:
 1330               	.LBE52:
 569:tmk_core/common/action.c ****                         } else {
 1331               		.loc 1 569 29 is_stmt 1 view .LVU359
 1332 01b4 8D2F      		mov r24,r29
 1333 01b6 0E94 0000 		call unregister_code
 1334               	.LVL134:
 1335 01ba 00C0      		rjmp .L61
 1336               	.L69:
 391:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1337               		.loc 1 391 13 view .LVU360
 391:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1338               		.loc 1 391 33 is_stmt 0 view .LVU361
 1339 01bc 8C2F      		mov r24,r28
 1340 01be 8695      		lsr r24
 1341 01c0 8695      		lsr r24
 1342 01c2 8370      		andi r24,lo8(3)
 1343 01c4 01F0      		breq .L98
 1344 01c6 8130      		cpi r24,lo8(1)
 1345 01c8 01F0      		breq .+2
 1346 01ca 00C0      		rjmp .L61
 400:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1347               		.loc 1 400 21 is_stmt 1 view .LVU362
 401:tmk_core/common/action.c ****                     } else {
 1348               		.loc 1 401 25 is_stmt 0 view .LVU363
 1349 01cc 8D2F      		mov r24,r29
 1350 01ce 9C2F      		mov r25,r28
 1351 01d0 9370      		andi r25,lo8(3)
 400:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1352               		.loc 1 400 24 view .LVU364
 1353 01d2 1111      		cpse r17,__zero_reg__
 1354 01d4 00C0      		rjmp .L171
 403:tmk_core/common/action.c ****                     }
 1355               		.loc 1 403 25 is_stmt 1 view .LVU365
 1356 01d6 90E0      		ldi r25,0
 1357 01d8 80E0      		ldi r24,0
 1358               	.L171:
 1359 01da 0E94 0000 		call host_consumer_send
 1360               	.LVL135:
 1361 01de 00C0      		rjmp .L61
 1362               	.L98:
 393:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1363               		.loc 1 393 21 view .LVU366
 394:tmk_core/common/action.c ****                     } else {
 1364               		.loc 1 394 25 is_stmt 0 view .LVU367
 1365 01e0 8D2F      		mov r24,r29
 1366 01e2 9C2F      		mov r25,r28
 1367 01e4 9370      		andi r25,lo8(3)
 393:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1368               		.loc 1 393 24 view .LVU368
 1369 01e6 1111      		cpse r17,__zero_reg__
 1370 01e8 00C0      		rjmp .L167
 396:tmk_core/common/action.c ****                     }
 1371               		.loc 1 396 25 is_stmt 1 view .LVU369
 1372 01ea 90E0      		ldi r25,0
 1373 01ec 80E0      		ldi r24,0
 1374               	.L167:
 1375 01ee 0E94 0000 		call host_system_send
 1376               	.LVL136:
 1377 01f2 00C0      		rjmp .L61
 1378               	.L68:
 412:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1379               		.loc 1 412 13 view .LVU370
 413:tmk_core/common/action.c ****             } else {
 1380               		.loc 1 413 17 is_stmt 0 view .LVU371
 1381 01f4 8D2F      		mov r24,r29
 412:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1382               		.loc 1 412 16 view .LVU372
 1383 01f6 1123      		tst r17
 1384 01f8 01F0      		breq .L102
 413:tmk_core/common/action.c ****             } else {
 1385               		.loc 1 413 17 is_stmt 1 view .LVU373
 1386 01fa 0E94 0000 		call mousekey_on
 1387               	.LVL137:
 1388               	.L103:
 417:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1389               		.loc 1 417 13 view .LVU374
 428:tmk_core/common/action.c ****                     break;
 1390               		.loc 1 428 21 view .LVU375
 1391 01fe 0E94 0000 		call mousekey_send
 1392               	.LVL138:
 429:tmk_core/common/action.c ****             }
 1393               		.loc 1 429 21 view .LVU376
 1394 0202 00C0      		rjmp .L61
 1395               	.L102:
 415:tmk_core/common/action.c ****             }
 1396               		.loc 1 415 17 view .LVU377
 1397 0204 0E94 0000 		call mousekey_off
 1398               	.LVL139:
 1399 0208 00C0      		rjmp .L103
 1400               	.L67:
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1401               		.loc 1 435 13 view .LVU378
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1402               		.loc 1 435 39 is_stmt 0 view .LVU379
 1403 020a 8C2F      		mov r24,r28
 1404 020c 8370      		andi r24,lo8(3)
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1405               		.loc 1 435 16 view .LVU380
 1406 020e 01F0      		breq .+2
 1407 0210 00C0      		rjmp .L104
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1408               		.loc 1 437 17 is_stmt 1 view .LVU381
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1409               		.loc 1 437 20 is_stmt 0 view .LVU382
 1410 0212 1111      		cpse r17,__zero_reg__
 1411 0214 00C0      		rjmp .L61
 1412               	.LBB55:
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1413               		.loc 1 438 21 is_stmt 1 view .LVU383
 1414               	.LVL140:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1415               		.loc 1 439 21 view .LVU384
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1416               		.loc 1 438 61 is_stmt 0 view .LVU385
 1417 0216 4D2F      		mov r20,r29
 1418 0218 4295      		swap r20
 1419 021a 4695      		lsr r20
 1420 021c 4770      		andi r20,lo8(7)
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1421               		.loc 1 438 35 view .LVU386
 1422 021e 440F      		lsl r20
 1423 0220 440F      		lsl r20
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1424               		.loc 1 439 77 view .LVU387
 1425 0222 0D2F      		mov r16,r29
 1426               	.LVL141:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1427               		.loc 1 439 77 view .LVU388
 1428 0224 0F70      		andi r16,lo8(15)
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1429               		.loc 1 439 44 view .LVU389
 1430 0226 10E0      		ldi r17,0
 1431               	.LVL142:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1432               		.loc 1 439 44 view .LVU390
 1433 0228 30E0      		ldi r19,0
 1434 022a 20E0      		ldi r18,0
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1435               		.loc 1 439 35 view .LVU391
 1436 022c 042E      		mov r0,r20
 1437 022e 00C0      		rjmp 2f
 1438               		1:
 1439 0230 000F      		lsl r16
 1440 0232 111F      		rol r17
 1441 0234 221F      		rol r18
 1442 0236 331F      		rol r19
 1443               		2:
 1444 0238 0A94      		dec r0
 1445 023a 02F4      		brpl 1b
 1446               	.LVL143:
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1447               		.loc 1 440 21 is_stmt 1 view .LVU392
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1448               		.loc 1 440 104 is_stmt 0 view .LVU393
 1449 023c 60E0      		ldi r22,0
 1450 023e 70E0      		ldi r23,0
 1451 0240 CB01      		movw r24,r22
 1452 0242 D4FF      		sbrs r29,4
 1453 0244 00C0      		rjmp .L105
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1454               		.loc 1 440 94 discriminator 1 view .LVU394
 1455 0246 6FE0      		ldi r22,lo8(15)
 1456 0248 70E0      		ldi r23,0
 1457 024a 80E0      		ldi r24,0
 1458 024c 90E0      		ldi r25,0
 1459 024e 00C0      		rjmp 2f
 1460               		1:
 1461 0250 660F      		lsl r22
 1462 0252 771F      		rol r23
 1463 0254 881F      		rol r24
 1464 0256 991F      		rol r25
 1465               		2:
 1466 0258 4A95      		dec r20
 1467 025a 02F4      		brpl 1b
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1468               		.loc 1 440 104 discriminator 1 view .LVU395
 1469 025c 6095      		com r22
 1470 025e 7095      		com r23
 1471 0260 8095      		com r24
 1472 0262 9095      		com r25
 1473               	.L105:
 1474               	.LVL144:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1475               		.loc 1 441 21 is_stmt 1 discriminator 4 view .LVU396
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1476               		.loc 1 441 47 is_stmt 0 discriminator 4 view .LVU397
 1477 0264 C695      		lsr r28
 1478 0266 C695      		lsr r28
 1479               	.LVL145:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1480               		.loc 1 441 47 discriminator 4 view .LVU398
 1481 0268 C370      		andi r28,lo8(3)
 1482 026a 602B      		or r22,r16
 1483               	.LVL146:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1484               		.loc 1 441 47 discriminator 4 view .LVU399
 1485 026c 712B      		or r23,r17
 1486 026e 822B      		or r24,r18
 1487 0270 932B      		or r25,r19
 1488 0272 C230      		cpi r28,lo8(2)
 1489 0274 01F0      		breq .L106
 1490 0276 00F4      		brsh .L107
 1491 0278 C130      		cpi r28,lo8(1)
 1492 027a 01F0      		breq .L108
 443:tmk_core/common/action.c ****                             break;
 1493               		.loc 1 443 29 is_stmt 1 view .LVU400
 1494 027c 0E94 0000 		call default_layer_and
 1495               	.LVL147:
 444:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1496               		.loc 1 444 29 view .LVU401
 1497 0280 00C0      		rjmp .L61
 1498               	.L108:
 446:tmk_core/common/action.c ****                             break;
 1499               		.loc 1 446 29 view .LVU402
 1500 0282 0E94 0000 		call default_layer_or
 1501               	.LVL148:
 447:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1502               		.loc 1 447 29 view .LVU403
 1503 0286 00C0      		rjmp .L61
 1504               	.L106:
 449:tmk_core/common/action.c ****                             break;
 1505               		.loc 1 449 29 view .LVU404
 1506 0288 0E94 0000 		call default_layer_xor
 1507               	.LVL149:
 450:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1508               		.loc 1 450 29 view .LVU405
 1509 028c 00C0      		rjmp .L61
 1510               	.L107:
 452:tmk_core/common/action.c ****                             break;
 1511               		.loc 1 452 29 view .LVU406
 1512 028e 0E94 0000 		call default_layer_set
 1513               	.LVL150:
 453:tmk_core/common/action.c ****                     }
 1514               		.loc 1 453 29 view .LVU407
 1515 0292 00C0      		rjmp .L61
 1516               	.LVL151:
 1517               	.L104:
 453:tmk_core/common/action.c ****                     }
 1518               		.loc 1 453 29 is_stmt 0 view .LVU408
 1519               	.LBE55:
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1520               		.loc 1 458 17 is_stmt 1 view .LVU409
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1521               		.loc 1 458 21 is_stmt 0 view .LVU410
 1522 0294 8695      		lsr r24
 1523 0296 1123      		tst r17
 1524 0298 01F0      		breq .L110
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1525               		.loc 1 458 21 discriminator 1 view .LVU411
 1526 029a 8C2F      		mov r24,r28
 1527 029c 8170      		andi r24,lo8(1)
 1528               	.L110:
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1529               		.loc 1 458 20 discriminator 4 view .LVU412
 1530 029e 8823      		tst r24
 1531 02a0 01F4      		brne .+2
 1532 02a2 00C0      		rjmp .L61
 1533               	.LBB56:
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1534               		.loc 1 459 21 is_stmt 1 view .LVU413
 1535               	.LVL152:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1536               		.loc 1 460 21 view .LVU414
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1537               		.loc 1 459 61 is_stmt 0 view .LVU415
 1538 02a4 4D2F      		mov r20,r29
 1539 02a6 4295      		swap r20
 1540 02a8 4695      		lsr r20
 1541 02aa 4770      		andi r20,lo8(7)
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1542               		.loc 1 459 35 view .LVU416
 1543 02ac 440F      		lsl r20
 1544 02ae 440F      		lsl r20
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1545               		.loc 1 460 77 view .LVU417
 1546 02b0 0D2F      		mov r16,r29
 1547               	.LVL153:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1548               		.loc 1 460 77 view .LVU418
 1549 02b2 0F70      		andi r16,lo8(15)
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1550               		.loc 1 460 44 view .LVU419
 1551 02b4 10E0      		ldi r17,0
 1552               	.LVL154:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1553               		.loc 1 460 44 view .LVU420
 1554 02b6 30E0      		ldi r19,0
 1555 02b8 20E0      		ldi r18,0
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1556               		.loc 1 460 35 view .LVU421
 1557 02ba 042E      		mov r0,r20
 1558 02bc 00C0      		rjmp 2f
 1559               		1:
 1560 02be 000F      		lsl r16
 1561 02c0 111F      		rol r17
 1562 02c2 221F      		rol r18
 1563 02c4 331F      		rol r19
 1564               		2:
 1565 02c6 0A94      		dec r0
 1566 02c8 02F4      		brpl 1b
 1567               	.LVL155:
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1568               		.loc 1 461 21 is_stmt 1 view .LVU422
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1569               		.loc 1 461 104 is_stmt 0 view .LVU423
 1570 02ca 60E0      		ldi r22,0
 1571 02cc 70E0      		ldi r23,0
 1572 02ce CB01      		movw r24,r22
 1573 02d0 D4FF      		sbrs r29,4
 1574 02d2 00C0      		rjmp .L111
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1575               		.loc 1 461 94 discriminator 1 view .LVU424
 1576 02d4 6FE0      		ldi r22,lo8(15)
 1577 02d6 70E0      		ldi r23,0
 1578 02d8 80E0      		ldi r24,0
 1579 02da 90E0      		ldi r25,0
 1580 02dc 00C0      		rjmp 2f
 1581               		1:
 1582 02de 660F      		lsl r22
 1583 02e0 771F      		rol r23
 1584 02e2 881F      		rol r24
 1585 02e4 991F      		rol r25
 1586               		2:
 1587 02e6 4A95      		dec r20
 1588 02e8 02F4      		brpl 1b
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1589               		.loc 1 461 104 discriminator 1 view .LVU425
 1590 02ea 6095      		com r22
 1591 02ec 7095      		com r23
 1592 02ee 8095      		com r24
 1593 02f0 9095      		com r25
 1594               	.L111:
 1595               	.LVL156:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1596               		.loc 1 462 21 is_stmt 1 discriminator 4 view .LVU426
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1597               		.loc 1 462 47 is_stmt 0 discriminator 4 view .LVU427
 1598 02f2 C695      		lsr r28
 1599 02f4 C695      		lsr r28
 1600               	.LVL157:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1601               		.loc 1 462 47 discriminator 4 view .LVU428
 1602 02f6 C370      		andi r28,lo8(3)
 1603 02f8 602B      		or r22,r16
 1604               	.LVL158:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1605               		.loc 1 462 47 discriminator 4 view .LVU429
 1606 02fa 712B      		or r23,r17
 1607 02fc 822B      		or r24,r18
 1608 02fe 932B      		or r25,r19
 1609 0300 C230      		cpi r28,lo8(2)
 1610 0302 01F0      		breq .L112
 1611 0304 00F4      		brsh .L113
 1612 0306 C130      		cpi r28,lo8(1)
 1613 0308 01F0      		breq .L114
 464:tmk_core/common/action.c ****                             break;
 1614               		.loc 1 464 29 is_stmt 1 view .LVU430
 1615 030a 0E94 0000 		call layer_and
 1616               	.LVL159:
 465:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1617               		.loc 1 465 29 view .LVU431
 1618 030e 00C0      		rjmp .L61
 1619               	.L114:
 467:tmk_core/common/action.c ****                             break;
 1620               		.loc 1 467 29 view .LVU432
 1621 0310 0E94 0000 		call layer_or
 1622               	.LVL160:
 468:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1623               		.loc 1 468 29 view .LVU433
 1624 0314 00C0      		rjmp .L61
 1625               	.L112:
 470:tmk_core/common/action.c ****                             break;
 1626               		.loc 1 470 29 view .LVU434
 1627 0316 0E94 0000 		call layer_xor
 1628               	.LVL161:
 471:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1629               		.loc 1 471 29 view .LVU435
 1630 031a 00C0      		rjmp .L61
 1631               	.L113:
 473:tmk_core/common/action.c ****                             break;
 1632               		.loc 1 473 29 view .LVU436
 1633 031c 0E94 0000 		call layer_state_set
 1634               	.LVL162:
 474:tmk_core/common/action.c ****                     }
 1635               		.loc 1 474 29 view .LVU437
 1636 0320 00C0      		rjmp .L61
 1637               	.LVL163:
 1638               	.L66:
 474:tmk_core/common/action.c ****                     }
 1639               		.loc 1 474 29 is_stmt 0 view .LVU438
 1640               	.LBE56:
 480:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1641               		.loc 1 480 13 is_stmt 1 view .LVU439
 1642 0322 CF70      		andi r28,lo8(15)
 1643               	.LVL164:
 480:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1644               		.loc 1 480 16 is_stmt 0 view .LVU440
 1645 0324 1123      		tst r17
 1646 0326 01F0      		breq .L115
 481:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1647               		.loc 1 481 17 is_stmt 1 view .LVU441
 1648 0328 8C2F      		mov r24,r28
 1649 032a 0E94 0000 		call layer_on
 1650               	.LVL165:
 482:tmk_core/common/action.c ****             } else {
 1651               		.loc 1 482 17 view .LVU442
 1652 032e 8D2F      		mov r24,r29
 1653 0330 00C0      		rjmp .L169
 1654               	.L115:
 484:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1655               		.loc 1 484 17 view .LVU443
 1656 0332 8D2F      		mov r24,r29
 1657 0334 0E94 0000 		call unregister_mods
 1658               	.LVL166:
 485:tmk_core/common/action.c ****             }
 1659               		.loc 1 485 17 view .LVU444
 1660 0338 8C2F      		mov r24,r28
 1661               	.LVL167:
 1662               	.L166:
 572:tmk_core/common/action.c ****                         }
 1663               		.loc 1 572 29 is_stmt 0 view .LVU445
 1664 033a 0E94 0000 		call layer_off
 1665               	.LVL168:
 1666 033e 00C0      		rjmp .L61
 1667               	.L65:
 491:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1668               		.loc 1 491 13 is_stmt 1 view .LVU446
 1669 0340 D23F      		cpi r29,lo8(-14)
 1670 0342 01F0      		breq .L116
 1671 0344 00F4      		brsh .L117
 1672 0346 D03F      		cpi r29,lo8(-16)
 1673 0348 01F0      		breq .L118
 1674 034a D13F      		cpi r29,lo8(-15)
 1675 034c 01F0      		breq .L119
 1676               	.L120:
 553:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1677               		.loc 1 553 21 view .LVU447
 553:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1678               		.loc 1 553 24 is_stmt 0 view .LVU448
 1679 034e 1123      		tst r17
 1680 0350 01F4      		brne .+2
 1681 0352 00C0      		rjmp .L129
 554:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1682               		.loc 1 554 25 is_stmt 1 view .LVU449
 554:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1683               		.loc 1 554 28 is_stmt 0 view .LVU450
 1684 0354 0111      		cpse r16,__zero_reg__
 1685 0356 00C0      		rjmp .L170
 558:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1686               		.loc 1 558 76 is_stmt 1 view .LVU451
 559:tmk_core/common/action.c ****                         }
 1687               		.loc 1 559 29 view .LVU452
 1688 0358 8C2F      		mov r24,r28
 1689 035a 8F71      		andi r24,lo8(31)
 1690 035c 00C0      		rjmp .L168
 1691               	.L117:
 1692 035e D33F      		cpi r29,lo8(-13)
 1693 0360 01F0      		breq .L121
 1694 0362 D43F      		cpi r29,lo8(-12)
 1695 0364 01F4      		brne .L120
 539:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1696               		.loc 1 539 21 view .LVU453
 539:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1697               		.loc 1 539 24 is_stmt 0 view .LVU454
 1698 0366 1123      		tst r17
 1699 0368 01F0      		breq .L128
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1700               		.loc 1 540 25 is_stmt 1 view .LVU455
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1701               		.loc 1 540 50 is_stmt 0 view .LVU456
 1702 036a CF71      		andi r28,lo8(31)
 1703               	.LVL169:
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1704               		.loc 1 540 25 view .LVU457
 1705 036c 8C2F      		mov r24,r28
 1706 036e 0E94 0000 		call layer_on
 1707               	.LVL170:
 541:tmk_core/common/action.c ****                     } else {
 1708               		.loc 1 541 25 is_stmt 1 view .LVU458
 1709 0372 63E0      		ldi r22,lo8(3)
 1710 0374 8C2F      		mov r24,r28
 1711 0376 0E94 0000 		call set_oneshot_layer
 1712               	.LVL171:
 1713 037a 00C0      		rjmp .L61
 1714               	.LVL172:
 1715               	.L118:
 494:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1716               		.loc 1 494 21 view .LVU459
 494:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1717               		.loc 1 494 24 is_stmt 0 view .LVU460
 1718 037c 1123      		tst r17
 1719 037e 01F0      		breq .L123
 495:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1720               		.loc 1 495 25 is_stmt 1 view .LVU461
 495:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1721               		.loc 1 495 28 is_stmt 0 view .LVU462
 1722 0380 0530      		cpi r16,lo8(5)
 1723 0382 00F0      		brlo .+2
 1724 0384 00C0      		rjmp .L61
 1725               	.L124:
 496:tmk_core/common/action.c ****                         }
 1726               		.loc 1 496 29 is_stmt 1 view .LVU463
 1727 0386 8C2F      		mov r24,r28
 1728 0388 8F71      		andi r24,lo8(31)
 1729 038a 0E94 0000 		call layer_invert
 1730               	.LVL173:
 1731 038e 00C0      		rjmp .L61
 1732               	.L123:
 499:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1733               		.loc 1 499 25 view .LVU464
 499:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1734               		.loc 1 499 28 is_stmt 0 view .LVU465
 1735 0390 0630      		cpi r16,lo8(6)
 1736 0392 00F0      		brlo .+2
 1737 0394 00C0      		rjmp .L61
 1738 0396 00C0      		rjmp .L124
 1739               	.L119:
 505:tmk_core/common/action.c ****                     break;
 1740               		.loc 1 505 21 is_stmt 1 view .LVU466
 1741 0398 8C2F      		mov r24,r28
 1742 039a 8F71      		andi r24,lo8(31)
 505:tmk_core/common/action.c ****                     break;
 1743               		.loc 1 505 68 is_stmt 0 view .LVU467
 1744 039c 1123      		tst r17
 1745 039e 01F0      		breq .L166
 1746               	.L168:
 559:tmk_core/common/action.c ****                         }
 1747               		.loc 1 559 29 view .LVU468
 1748 03a0 0E94 0000 		call layer_on
 1749               	.LVL174:
 1750 03a4 00C0      		rjmp .L61
 1751               	.L116:
 508:tmk_core/common/action.c ****                     break;
 1752               		.loc 1 508 21 is_stmt 1 view .LVU469
 1753 03a6 8C2F      		mov r24,r28
 1754 03a8 8F71      		andi r24,lo8(31)
 508:tmk_core/common/action.c ****                     break;
 1755               		.loc 1 508 69 is_stmt 0 view .LVU470
 1756 03aa 1123      		tst r17
 1757 03ac 01F0      		breq .L168
 1758 03ae 00C0      		rjmp .L166
 1759               	.L121:
 511:tmk_core/common/action.c ****                     break;
 1760               		.loc 1 511 21 is_stmt 1 view .LVU471
 511:tmk_core/common/action.c ****                     break;
 1761               		.loc 1 511 70 is_stmt 0 view .LVU472
 1762 03b0 1123      		tst r17
 1763 03b2 01F0      		breq .L127
 511:tmk_core/common/action.c ****                     break;
 1764               		.loc 1 511 37 discriminator 1 view .LVU473
 1765 03b4 8C2F      		mov r24,r28
 1766 03b6 8F71      		andi r24,lo8(31)
 1767 03b8 0E94 0000 		call layer_move
 1768               	.LVL175:
 1769 03bc 00C0      		rjmp .L61
 1770               	.L127:
 511:tmk_core/common/action.c ****                     break;
 1771               		.loc 1 511 72 discriminator 2 view .LVU474
 1772 03be 0E94 0000 		call layer_clear
 1773               	.LVL176:
 1774 03c2 00C0      		rjmp .L61
 1775               	.L128:
 543:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1776               		.loc 1 543 25 is_stmt 1 view .LVU475
 1777 03c4 81E0      		ldi r24,lo8(1)
 1778 03c6 0E94 0000 		call clear_oneshot_layer_state
 1779               	.LVL177:
 544:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1780               		.loc 1 544 25 view .LVU476
 544:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1781               		.loc 1 544 28 is_stmt 0 view .LVU477
 1782 03ca 0230      		cpi r16,lo8(2)
 1783 03cc 00F4      		brsh .+2
 1784 03ce 00C0      		rjmp .L61
 545:tmk_core/common/action.c ****                         }
 1785               		.loc 1 545 29 is_stmt 1 view .LVU478
 1786 03d0 82E0      		ldi r24,lo8(2)
 1787 03d2 0E94 0000 		call clear_oneshot_layer_state
 1788               	.LVL178:
 1789 03d6 00C0      		rjmp .L61
 1790               	.L129:
 562:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1791               		.loc 1 562 25 view .LVU479
 562:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1792               		.loc 1 562 28 is_stmt 0 view .LVU480
 1793 03d8 0023      		tst r16
 1794 03da 01F0      		breq .L131
 563:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1795               		.loc 1 563 77 is_stmt 1 view .LVU481
 564:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1796               		.loc 1 564 29 view .LVU482
 564:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1797               		.loc 1 564 32 is_stmt 0 view .LVU483
 1798 03dc D933      		cpi r29,lo8(57)
 1799 03de 01F0      		breq .+2
 1800 03e0 00C0      		rjmp .L133
 565:tmk_core/common/action.c ****                             } else {
 1801               		.loc 1 565 33 is_stmt 1 view .LVU484
 1802               	.LVL179:
 1803               	.LBB57:
 1804               	.LBI52:
 166:c:\qmk_msys\mingw64\avr\include\util\delay.h **** {
 1805               		.loc 2 166 1 view .LVU485
 1806               	.LBB54:
 168:c:\qmk_msys\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1807               		.loc 2 168 2 view .LVU486
 172:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1808               		.loc 2 172 2 view .LVU487
 173:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1809               		.loc 2 173 2 view .LVU488
 174:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 
 1810               		.loc 2 174 2 view .LVU489
 184:c:\qmk_msys\mingw64\avr\include\util\delay.h **** 	#endif
 1811               		.loc 2 184 3 view .LVU490
 1812               		.loc 2 187 2 view .LVU491
 1813 03e2 8FEF      		ldi r24,lo8(255999)
 1814 03e4 97EE      		ldi r25,hi8(255999)
 1815 03e6 E3E0      		ldi r30,hlo8(255999)
 1816 03e8 8150      	1:	subi r24,1
 1817 03ea 9040      		sbci r25,0
 1818 03ec E040      		sbci r30,0
 1819 03ee 01F4      		brne 1b
 1820 03f0 00C0      		rjmp .L173
 1821               	.LVL180:
 1822               	.L131:
 1823               		.loc 2 187 2 is_stmt 0 view .LVU492
 1824               	.LBE54:
 1825               	.LBE57:
 571:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1826               		.loc 1 571 79 is_stmt 1 view .LVU493
 572:tmk_core/common/action.c ****                         }
 1827               		.loc 1 572 29 view .LVU494
 1828 03f2 8C2F      		mov r24,r28
 1829 03f4 8F71      		andi r24,lo8(31)
 1830 03f6 00C0      		rjmp .L166
 1831               	.L64:
 583:tmk_core/common/action.c ****             break;
 1832               		.loc 1 583 13 view .LVU495
 583:tmk_core/common/action.c ****             break;
 1833               		.loc 1 583 83 is_stmt 0 view .LVU496
 1834 03f8 4C2F      		mov r20,r28
 1835 03fa 4F70      		andi r20,lo8(15)
 583:tmk_core/common/action.c ****             break;
 1836               		.loc 1 583 13 view .LVU497
 1837 03fc 6D2F      		mov r22,r29
 1838 03fe C601      		movw r24,r12
 1839 0400 0E94 0000 		call action_get_macro
 1840               	.LVL181:
 1841 0404 0E94 0000 		call action_macro_play
 1842               	.LVL182:
 584:tmk_core/common/action.c **** #endif
 1843               		.loc 1 584 13 is_stmt 1 view .LVU498
 1844 0408 00C0      		rjmp .L61
 1845               	.L62:
 661:tmk_core/common/action.c ****             break;
 1846               		.loc 1 661 13 view .LVU499
 661:tmk_core/common/action.c ****             break;
 1847               		.loc 1 661 64 is_stmt 0 view .LVU500
 1848 040a 4C2F      		mov r20,r28
 1849 040c 4F70      		andi r20,lo8(15)
 661:tmk_core/common/action.c ****             break;
 1850               		.loc 1 661 13 view .LVU501
 1851 040e 6D2F      		mov r22,r29
 1852 0410 C601      		movw r24,r12
 1853 0412 0E94 0000 		call action_function
 1854               	.LVL183:
 662:tmk_core/common/action.c **** #endif
 1855               		.loc 1 662 13 is_stmt 1 view .LVU502
 1856 0416 00C0      		rjmp .L61
 1857               	.LVL184:
 1858               	.L58:
 1859               	/* epilogue start */
 730:tmk_core/common/action.c **** 
 1860               		.loc 1 730 1 is_stmt 0 view .LVU503
 1861 0418 DF91      		pop r29
 1862               	.LVL185:
 730:tmk_core/common/action.c **** 
 1863               		.loc 1 730 1 view .LVU504
 1864 041a CF91      		pop r28
 730:tmk_core/common/action.c **** 
 1865               		.loc 1 730 1 view .LVU505
 1866 041c 1F91      		pop r17
 1867 041e 0F91      		pop r16
 1868 0420 FF90      		pop r15
 1869 0422 EF90      		pop r14
 1870               	.LVL186:
 730:tmk_core/common/action.c **** 
 1871               		.loc 1 730 1 view .LVU506
 1872 0424 DF90      		pop r13
 1873 0426 CF90      		pop r12
 1874               	.LVL187:
 730:tmk_core/common/action.c **** 
 1875               		.loc 1 730 1 view .LVU507
 1876 0428 BF90      		pop r11
 1877 042a 0895      		ret
 1878               		.cfi_endproc
 1879               	.LFE22:
 1881               		.section	.text.process_record_handler,"ax",@progbits
 1882               	.global	process_record_handler
 1884               	process_record_handler:
 1885               	.LVL188:
 1886               	.LFB21:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1887               		.loc 1 208 50 is_stmt 1 view -0
 1888               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1889               		.loc 1 208 50 is_stmt 0 view .LVU509
 1890 0000 0F93      		push r16
 1891               	.LCFI22:
 1892               		.cfi_def_cfa_offset 3
 1893               		.cfi_offset 16, -2
 1894 0002 1F93      		push r17
 1895               	.LCFI23:
 1896               		.cfi_def_cfa_offset 4
 1897               		.cfi_offset 17, -3
 1898 0004 CF93      		push r28
 1899               	.LCFI24:
 1900               		.cfi_def_cfa_offset 5
 1901               		.cfi_offset 28, -4
 1902 0006 DF93      		push r29
 1903               	.LCFI25:
 1904               		.cfi_def_cfa_offset 6
 1905               		.cfi_offset 29, -5
 1906               	/* prologue: function */
 1907               	/* frame size = 0 */
 1908               	/* stack size = 4 */
 1909               	.L__stack_usage = 4
 1910 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1911               		.loc 1 209 5 is_stmt 1 view .LVU510
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1912               		.loc 1 209 23 is_stmt 0 view .LVU511
 1913 000a 6881      		ld r22,Y
 1914 000c 7981      		ldd r23,Y+1
 1915 000e 8A81      		ldd r24,Y+2
 1916               	.LVL189:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1917               		.loc 1 209 23 view .LVU512
 1918 0010 0E94 0000 		call store_or_get_action
 1919               	.LVL190:
 1920 0014 8C01      		movw r16,r24
 1921               	.LVL191:
 210:tmk_core/common/action.c ****     debug_action(action);
 1922               		.loc 1 210 23 is_stmt 1 view .LVU513
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1923               		.loc 1 211 5 view .LVU514
 213:tmk_core/common/action.c ****     layer_debug();
 1924               		.loc 1 213 29 view .LVU515
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1925               		.loc 1 214 5 view .LVU516
 1926 0016 0E94 0000 		call layer_debug
 1927               	.LVL192:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1928               		.loc 1 215 37 view .LVU517
 216:tmk_core/common/action.c **** #endif
 1929               		.loc 1 216 5 view .LVU518
 1930 001a 0E94 0000 		call default_layer_debug
 1931               	.LVL193:
 218:tmk_core/common/action.c **** 
 1932               		.loc 1 218 15 view .LVU519
 220:tmk_core/common/action.c **** }
 1933               		.loc 1 220 5 view .LVU520
 220:tmk_core/common/action.c **** }
 1934               		.loc 1 220 5 is_stmt 0 view .LVU521
 1935 001e B801      		movw r22,r16
 1936 0020 CE01      		movw r24,r28
 1937               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 1938               		.loc 1 221 1 view .LVU522
 1939 0022 DF91      		pop r29
 1940 0024 CF91      		pop r28
 1941               	.LVL194:
 221:tmk_core/common/action.c **** 
 1942               		.loc 1 221 1 view .LVU523
 1943 0026 1F91      		pop r17
 1944 0028 0F91      		pop r16
 1945               	.LVL195:
 220:tmk_core/common/action.c **** }
 1946               		.loc 1 220 5 view .LVU524
 1947 002a 0C94 0000 		jmp process_action
 1948               	.LVL196:
 220:tmk_core/common/action.c **** }
 1949               		.loc 1 220 5 view .LVU525
 1950               		.cfi_endproc
 1951               	.LFE21:
 1953               		.section	.text.process_record,"ax",@progbits
 1954               	.global	process_record
 1956               	process_record:
 1957               	.LVL197:
 1958               	.LFB20:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1959               		.loc 1 190 42 is_stmt 1 view -0
 1960               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1961               		.loc 1 190 42 is_stmt 0 view .LVU527
 1962 0000 CF93      		push r28
 1963               	.LCFI26:
 1964               		.cfi_def_cfa_offset 3
 1965               		.cfi_offset 28, -2
 1966 0002 DF93      		push r29
 1967               	.LCFI27:
 1968               		.cfi_def_cfa_offset 4
 1969               		.cfi_offset 29, -3
 1970               	/* prologue: function */
 1971               	/* frame size = 0 */
 1972               	/* stack size = 2 */
 1973               	.L__stack_usage = 2
 1974 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 1975               		.loc 1 191 5 is_stmt 1 view .LVU528
 1976               	.LBB60:
 1977               	.LBI60:
 1978               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #pragma once
  19:tmk_core/common/keyboard.h **** 
  20:tmk_core/common/keyboard.h **** #include <stdbool.h>
  21:tmk_core/common/keyboard.h **** #include <stdint.h>
  22:tmk_core/common/keyboard.h **** 
  23:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  24:tmk_core/common/keyboard.h **** extern "C" {
  25:tmk_core/common/keyboard.h **** #endif
  26:tmk_core/common/keyboard.h **** 
  27:tmk_core/common/keyboard.h **** /* key matrix position */
  28:tmk_core/common/keyboard.h **** typedef struct {
  29:tmk_core/common/keyboard.h ****     uint8_t col;
  30:tmk_core/common/keyboard.h ****     uint8_t row;
  31:tmk_core/common/keyboard.h **** } keypos_t;
  32:tmk_core/common/keyboard.h **** 
  33:tmk_core/common/keyboard.h **** /* key event */
  34:tmk_core/common/keyboard.h **** typedef struct {
  35:tmk_core/common/keyboard.h ****     keypos_t key;
  36:tmk_core/common/keyboard.h ****     bool     pressed;
  37:tmk_core/common/keyboard.h ****     uint16_t time;
  38:tmk_core/common/keyboard.h **** } keyevent_t;
  39:tmk_core/common/keyboard.h **** 
  40:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  41:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:tmk_core/common/keyboard.h **** 
  43:tmk_core/common/keyboard.h **** /* Rules for No Event:
  44:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:tmk_core/common/keyboard.h ****  */
  47:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1979               		.loc 4 47 20 view .LVU529
 1980               	.LBB61:
 1981               		.loc 4 47 51 view .LVU530
 1982               		.loc 4 47 74 is_stmt 0 view .LVU531
 1983 0006 8B81      		ldd r24,Y+3
 1984 0008 9C81      		ldd r25,Y+4
 1985               	.LVL198:
 1986               		.loc 4 47 74 view .LVU532
 1987 000a 892B      		or r24,r25
 1988 000c 01F0      		breq .L175
 1989 000e 8881      		ld r24,Y
 1990 0010 9981      		ldd r25,Y+1
 1991 0012 8923      		and r24,r25
 1992 0014 8F3F      		cpi r24,lo8(-1)
 1993 0016 01F4      		brne .L191
 1994               	.L175:
 1995               	/* epilogue start */
 1996               	.LBE61:
 1997               	.LBE60:
 206:tmk_core/common/action.c **** 
 1998               		.loc 1 206 1 view .LVU533
 1999 0018 DF91      		pop r29
 2000 001a CF91      		pop r28
 2001               	.LVL199:
 206:tmk_core/common/action.c **** 
 2002               		.loc 1 206 1 view .LVU534
 2003 001c 0895      		ret
 2004               	.LVL200:
 2005               	.L180:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 2006               		.loc 1 204 5 is_stmt 1 view .LVU535
 2007 001e CE01      		movw r24,r28
 2008 0020 0E94 0000 		call process_record_handler
 2009               	.LVL201:
 205:tmk_core/common/action.c **** }
 2010               		.loc 1 205 5 view .LVU536
 2011 0024 CE01      		movw r24,r28
 2012               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 2013               		.loc 1 206 1 is_stmt 0 view .LVU537
 2014 0026 DF91      		pop r29
 2015 0028 CF91      		pop r28
 2016               	.LVL202:
 205:tmk_core/common/action.c **** }
 2017               		.loc 1 205 5 view .LVU538
 2018 002a 0C94 0000 		jmp post_process_record_quantum
 2019               	.LVL203:
 2020               	.L191:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2021               		.loc 1 195 5 is_stmt 1 view .LVU539
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2022               		.loc 1 195 10 is_stmt 0 view .LVU540
 2023 002e CE01      		movw r24,r28
 2024 0030 0E94 0000 		call process_record_quantum
 2025               	.LVL204:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2026               		.loc 1 195 8 view .LVU541
 2027 0034 8111      		cpse r24,__zero_reg__
 2028 0036 00C0      		rjmp .L180
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2029               		.loc 1 197 9 is_stmt 1 view .LVU542
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2030               		.loc 1 197 13 is_stmt 0 view .LVU543
 2031 0038 0E94 0000 		call is_oneshot_layer_active
 2032               	.LVL205:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2033               		.loc 1 197 12 view .LVU544
 2034 003c 8823      		tst r24
 2035 003e 01F0      		breq .L175
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2036               		.loc 1 197 39 discriminator 1 view .LVU545
 2037 0040 8A81      		ldd r24,Y+2
 2038 0042 8823      		tst r24
 2039 0044 01F0      		breq .L175
 198:tmk_core/common/action.c ****         }
 2040               		.loc 1 198 13 is_stmt 1 view .LVU546
 2041 0046 82E0      		ldi r24,lo8(2)
 2042               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 2043               		.loc 1 206 1 is_stmt 0 view .LVU547
 2044 0048 DF91      		pop r29
 2045 004a CF91      		pop r28
 2046               	.LVL206:
 198:tmk_core/common/action.c ****         }
 2047               		.loc 1 198 13 view .LVU548
 2048 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2049               	.LVL207:
 2050               		.cfi_endproc
 2051               	.LFE20:
 2053               		.section	.text.process_record_nocache,"ax",@progbits
 2054               	.global	process_record_nocache
 2056               	process_record_nocache:
 2057               	.LVL208:
 2058               	.LFB16:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 2059               		.loc 1 148 50 is_stmt 1 view -0
 2060               		.cfi_startproc
 2061               	/* prologue: function */
 2062               	/* frame size = 0 */
 2063               	/* stack size = 0 */
 2064               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 2065               		.loc 1 149 5 view .LVU550
 149:tmk_core/common/action.c ****     process_record(record);
 2066               		.loc 1 149 26 is_stmt 0 view .LVU551
 2067 0000 21E0      		ldi r18,lo8(1)
 2068 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 2069               		.loc 1 150 5 is_stmt 1 view .LVU552
 2070 0006 0E94 0000 		call process_record
 2071               	.LVL209:
 151:tmk_core/common/action.c **** }
 2072               		.loc 1 151 5 view .LVU553
 151:tmk_core/common/action.c **** }
 2073               		.loc 1 151 26 is_stmt 0 view .LVU554
 2074 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2075               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 2076               		.loc 1 152 1 view .LVU555
 2077 000e 0895      		ret
 2078               		.cfi_endproc
 2079               	.LFE16:
 2081               		.section	.text.register_weak_mods,"ax",@progbits
 2082               	.global	register_weak_mods
 2084               	register_weak_mods:
 2085               	.LVL210:
 2086               	.LFB29:
 925:tmk_core/common/action.c **** 
 926:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 927:tmk_core/common/action.c ****  *
 928:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 929:tmk_core/common/action.c ****  */
 930:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 2087               		.loc 1 930 39 is_stmt 1 view -0
 2088               		.cfi_startproc
 2089               	/* prologue: function */
 2090               	/* frame size = 0 */
 2091               	/* stack size = 0 */
 2092               	.L__stack_usage = 0
 931:tmk_core/common/action.c ****     if (mods) {
 2093               		.loc 1 931 5 view .LVU557
 2094               		.loc 1 931 8 is_stmt 0 view .LVU558
 2095 0000 8823      		tst r24
 2096 0002 01F0      		breq .L194
 932:tmk_core/common/action.c ****         add_weak_mods(mods);
 2097               		.loc 1 932 9 is_stmt 1 view .LVU559
 2098 0004 0E94 0000 		call add_weak_mods
 2099               	.LVL211:
 933:tmk_core/common/action.c ****         send_keyboard_report();
 2100               		.loc 1 933 9 view .LVU560
 2101 0008 0C94 0000 		jmp send_keyboard_report
 2102               	.LVL212:
 2103               	.L194:
 2104               	/* epilogue start */
 934:tmk_core/common/action.c ****     }
 935:tmk_core/common/action.c **** }
 2105               		.loc 1 935 1 is_stmt 0 view .LVU561
 2106 000c 0895      		ret
 2107               		.cfi_endproc
 2108               	.LFE29:
 2110               		.section	.text.unregister_weak_mods,"ax",@progbits
 2111               	.global	unregister_weak_mods
 2113               	unregister_weak_mods:
 2114               	.LVL213:
 2115               	.LFB30:
 936:tmk_core/common/action.c **** 
 937:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 938:tmk_core/common/action.c ****  *
 939:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 940:tmk_core/common/action.c ****  */
 941:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 2116               		.loc 1 941 41 is_stmt 1 view -0
 2117               		.cfi_startproc
 2118               	/* prologue: function */
 2119               	/* frame size = 0 */
 2120               	/* stack size = 0 */
 2121               	.L__stack_usage = 0
 942:tmk_core/common/action.c ****     if (mods) {
 2122               		.loc 1 942 5 view .LVU563
 2123               		.loc 1 942 8 is_stmt 0 view .LVU564
 2124 0000 8823      		tst r24
 2125 0002 01F0      		breq .L196
 943:tmk_core/common/action.c ****         del_weak_mods(mods);
 2126               		.loc 1 943 9 is_stmt 1 view .LVU565
 2127 0004 0E94 0000 		call del_weak_mods
 2128               	.LVL214:
 944:tmk_core/common/action.c ****         send_keyboard_report();
 2129               		.loc 1 944 9 view .LVU566
 2130 0008 0C94 0000 		jmp send_keyboard_report
 2131               	.LVL215:
 2132               	.L196:
 2133               	/* epilogue start */
 945:tmk_core/common/action.c ****     }
 946:tmk_core/common/action.c **** }
 2134               		.loc 1 946 1 is_stmt 0 view .LVU567
 2135 000c 0895      		ret
 2136               		.cfi_endproc
 2137               	.LFE30:
 2139               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2140               	.global	clear_keyboard_but_mods_and_keys
 2142               	clear_keyboard_but_mods_and_keys:
 2143               	.LFB33:
 947:tmk_core/common/action.c **** 
 948:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 949:tmk_core/common/action.c ****  *
 950:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:tmk_core/common/action.c ****  */
 952:tmk_core/common/action.c **** void clear_keyboard(void) {
 953:tmk_core/common/action.c ****     clear_mods();
 954:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 955:tmk_core/common/action.c **** }
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 962:tmk_core/common/action.c ****     clear_keys();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2144               		.loc 1 970 41 is_stmt 1 view -0
 2145               		.cfi_startproc
 2146               	/* prologue: function */
 2147               	/* frame size = 0 */
 2148               	/* stack size = 0 */
 2149               	.L__stack_usage = 0
 971:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 972:tmk_core/common/action.c ****     host_system_send(0);
 2150               		.loc 1 972 5 view .LVU569
 2151 0000 90E0      		ldi r25,0
 2152 0002 80E0      		ldi r24,0
 2153 0004 0E94 0000 		call host_system_send
 2154               	.LVL216:
 973:tmk_core/common/action.c ****     host_consumer_send(0);
 2155               		.loc 1 973 5 view .LVU570
 2156 0008 90E0      		ldi r25,0
 2157 000a 80E0      		ldi r24,0
 2158 000c 0E94 0000 		call host_consumer_send
 2159               	.LVL217:
 974:tmk_core/common/action.c **** #endif
 975:tmk_core/common/action.c ****     clear_weak_mods();
 2160               		.loc 1 975 5 view .LVU571
 2161 0010 0E94 0000 		call clear_weak_mods
 2162               	.LVL218:
 976:tmk_core/common/action.c ****     clear_macro_mods();
 2163               		.loc 1 976 5 view .LVU572
 2164 0014 0E94 0000 		call clear_macro_mods
 2165               	.LVL219:
 977:tmk_core/common/action.c ****     send_keyboard_report();
 2166               		.loc 1 977 5 view .LVU573
 2167 0018 0E94 0000 		call send_keyboard_report
 2168               	.LVL220:
 978:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 979:tmk_core/common/action.c ****     mousekey_clear();
 2169               		.loc 1 979 5 view .LVU574
 2170 001c 0E94 0000 		call mousekey_clear
 2171               	.LVL221:
 980:tmk_core/common/action.c ****     mousekey_send();
 2172               		.loc 1 980 5 view .LVU575
 2173 0020 0C94 0000 		jmp mousekey_send
 2174               	.LVL222:
 2175               		.cfi_endproc
 2176               	.LFE33:
 2178               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2179               	.global	clear_keyboard_but_mods
 2181               	clear_keyboard_but_mods:
 2182               	.LFB32:
 961:tmk_core/common/action.c ****     clear_keys();
 2183               		.loc 1 961 36 view -0
 2184               		.cfi_startproc
 2185               	/* prologue: function */
 2186               	/* frame size = 0 */
 2187               	/* stack size = 0 */
 2188               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2189               		.loc 1 962 5 view .LVU577
 2190 0000 0E94 0000 		call clear_keys
 2191               	.LVL223:
 963:tmk_core/common/action.c **** }
 2192               		.loc 1 963 5 view .LVU578
 2193 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2194               	.LVL224:
 2195               		.cfi_endproc
 2196               	.LFE32:
 2198               		.section	.text.clear_keyboard,"ax",@progbits
 2199               	.global	clear_keyboard
 2201               	clear_keyboard:
 2202               	.LFB31:
 952:tmk_core/common/action.c ****     clear_mods();
 2203               		.loc 1 952 27 view -0
 2204               		.cfi_startproc
 2205               	/* prologue: function */
 2206               	/* frame size = 0 */
 2207               	/* stack size = 0 */
 2208               	.L__stack_usage = 0
 953:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2209               		.loc 1 953 5 view .LVU580
 2210 0000 0E94 0000 		call clear_mods
 2211               	.LVL225:
 954:tmk_core/common/action.c **** }
 2212               		.loc 1 954 5 view .LVU581
 2213 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2214               	.LVL226:
 2215               		.cfi_endproc
 2216               	.LFE31:
 2218               		.section	.text.is_tap_action,"ax",@progbits
 2219               	.global	is_tap_action
 2221               	is_tap_action:
 2222               	.LVL227:
 2223               	.LFB35:
 981:tmk_core/common/action.c **** #endif
 982:tmk_core/common/action.c **** }
 983:tmk_core/common/action.c **** 
 984:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 985:tmk_core/common/action.c ****  *
 986:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 987:tmk_core/common/action.c ****  */
 988:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 989:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 990:tmk_core/common/action.c ****     return is_tap_action(action);
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2224               		.loc 1 997 37 view -0
 2225               		.cfi_startproc
 2226               	/* prologue: function */
 2227               	/* frame size = 0 */
 2228               	/* stack size = 0 */
 2229               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     switch (action.kind.id) {
 2230               		.loc 1 998 5 view .LVU583
 2231               		.loc 1 998 24 is_stmt 0 view .LVU584
 2232 0000 E92F      		mov r30,r25
 2233 0002 E295      		swap r30
 2234 0004 EF70      		andi r30,lo8(15)
 2235               		.loc 1 998 5 view .LVU585
 2236 0006 E250      		subi r30,lo8(-(-2))
 2237 0008 EE30      		cpi r30,lo8(14)
 2238 000a 00F4      		brsh .L210
 2239 000c F0E0      		ldi r31,0
 2240 000e E050      		subi r30,lo8(-(gs(.L204)))
 2241 0010 F040      		sbci r31,hi8(-(gs(.L204)))
 2242 0012 0C94 0000 		jmp __tablejump2__
 2243               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2244               		.p2align	1
 2245               	.L204:
 2246 0000 0000      		.word gs(.L205)
 2247 0002 0000      		.word gs(.L205)
 2248 0004 0000      		.word gs(.L210)
 2249 0006 0000      		.word gs(.L210)
 2250 0008 0000      		.word gs(.L206)
 2251 000a 0000      		.word gs(.L210)
 2252 000c 0000      		.word gs(.L210)
 2253 000e 0000      		.word gs(.L210)
 2254 0010 0000      		.word gs(.L205)
 2255 0012 0000      		.word gs(.L205)
 2256 0014 0000      		.word gs(.L203)
 2257 0016 0000      		.word gs(.L210)
 2258 0018 0000      		.word gs(.L210)
 2259 001a 0000      		.word gs(.L203)
 2260               		.section	.text.is_tap_action
 2261               	.L205:
 999:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1000:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1001:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1002:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1003:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2262               		.loc 1 1003 13 is_stmt 1 view .LVU586
 2263 0016 803F      		cpi r24,lo8(-16)
 2264 0018 01F0      		breq .L213
 2265 001a 00F4      		brsh .L207
 2266 001c 883E      		cpi r24,lo8(-24)
 2267 001e 00F4      		brsh .L210
 2268               	.L213:
1004:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1005:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1006:tmk_core/common/action.c ****                 case OP_ONESHOT:
1007:tmk_core/common/action.c ****                     return true;
 2269               		.loc 1 1007 28 is_stmt 0 view .LVU587
 2270 0020 81E0      		ldi r24,lo8(1)
 2271               	.LVL228:
 2272               	/* epilogue start */
1008:tmk_core/common/action.c ****             }
1009:tmk_core/common/action.c ****             return false;
1010:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1011:tmk_core/common/action.c ****             switch (action.swap.code) {
1012:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1013:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1014:tmk_core/common/action.c ****                     return true;
1015:tmk_core/common/action.c ****             }
1016:tmk_core/common/action.c ****             return false;
1017:tmk_core/common/action.c ****         case ACT_MACRO:
1018:tmk_core/common/action.c ****         case ACT_FUNCTION:
1019:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1020:tmk_core/common/action.c ****                 return true;
1021:tmk_core/common/action.c ****             }
1022:tmk_core/common/action.c ****             return false;
1023:tmk_core/common/action.c ****     }
1024:tmk_core/common/action.c ****     return false;
1025:tmk_core/common/action.c **** }
 2273               		.loc 1 1025 1 view .LVU588
 2274 0022 0895      		ret
 2275               	.LVL229:
 2276               	.L207:
 2277               		.loc 1 1025 1 view .LVU589
 2278 0024 843F      		cpi r24,lo8(-12)
 2279 0026 01F0      		breq .L213
 2280               	.L210:
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2281               		.loc 1 1009 20 view .LVU590
 2282 0028 80E0      		ldi r24,0
 2283               	.LVL230:
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2284               		.loc 1 1009 20 view .LVU591
 2285 002a 0895      		ret
 2286               	.LVL231:
 2287               	.L206:
1011:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2288               		.loc 1 1011 13 is_stmt 1 view .LVU592
 2289 002c 883E      		cpi r24,lo8(-24)
 2290 002e 00F0      		brlo .L213
 2291 0030 813F      		cpi r24,lo8(-15)
 2292 0032 01F4      		brne .L210
 2293 0034 00C0      		rjmp .L213
 2294               	.L203:
1019:tmk_core/common/action.c ****                 return true;
 2295               		.loc 1 1019 13 view .LVU593
1019:tmk_core/common/action.c ****                 return true;
 2296               		.loc 1 1019 16 is_stmt 0 view .LVU594
 2297 0036 93FB      		bst r25,3
 2298 0038 8827      		clr r24
 2299 003a 80F9      		bld r24,0
 2300               	.LVL232:
1019:tmk_core/common/action.c ****                 return true;
 2301               		.loc 1 1019 16 view .LVU595
 2302 003c 0895      		ret
 2303               		.cfi_endproc
 2304               	.LFE35:
 2306               		.section	.text.is_tap_key,"ax",@progbits
 2307               	.global	is_tap_key
 2309               	is_tap_key:
 2310               	.LVL233:
 2311               	.LFB34:
 988:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2312               		.loc 1 988 31 is_stmt 1 view -0
 2313               		.cfi_startproc
 2314               	/* prologue: function */
 2315               	/* frame size = 0 */
 2316               	/* stack size = 0 */
 2317               	.L__stack_usage = 0
 989:tmk_core/common/action.c ****     return is_tap_action(action);
 2318               		.loc 1 989 5 view .LVU597
 989:tmk_core/common/action.c ****     return is_tap_action(action);
 2319               		.loc 1 989 23 is_stmt 0 view .LVU598
 2320 0000 0E94 0000 		call layer_switch_get_action
 2321               	.LVL234:
 990:tmk_core/common/action.c **** }
 2322               		.loc 1 990 5 is_stmt 1 view .LVU599
 990:tmk_core/common/action.c **** }
 2323               		.loc 1 990 12 is_stmt 0 view .LVU600
 2324 0004 0C94 0000 		jmp is_tap_action
 2325               	.LVL235:
 2326               		.cfi_endproc
 2327               	.LFE34:
 2329               		.section	.text.debug_event,"ax",@progbits
 2330               	.global	debug_event
 2332               	debug_event:
 2333               	.LFB36:
1026:tmk_core/common/action.c **** 
1027:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1028:tmk_core/common/action.c ****  *
1029:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1030:tmk_core/common/action.c ****  */
1031:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2334               		.loc 1 1031 36 is_stmt 1 view -0
 2335               		.cfi_startproc
 2336 0000 CF93      		push r28
 2337               	.LCFI28:
 2338               		.cfi_def_cfa_offset 3
 2339               		.cfi_offset 28, -2
 2340 0002 DF93      		push r29
 2341               	.LCFI29:
 2342               		.cfi_def_cfa_offset 4
 2343               		.cfi_offset 29, -3
 2344 0004 00D0      		rcall .
 2345 0006 00D0      		rcall .
 2346 0008 0F92      		push __tmp_reg__
 2347               	.LCFI30:
 2348               		.cfi_def_cfa_offset 9
 2349 000a CDB7      		in r28,__SP_L__
 2350 000c DEB7      		in r29,__SP_H__
 2351               	.LCFI31:
 2352               		.cfi_def_cfa_register 28
 2353               	/* prologue: function */
 2354               	/* frame size = 5 */
 2355               	/* stack size = 7 */
 2356               	.L__stack_usage = 7
 2357               		.loc 1 1031 138 view .LVU602
 2358               	/* epilogue start */
 2359               		.loc 1 1031 1 is_stmt 0 view .LVU603
 2360 000e 0F90      		pop __tmp_reg__
 2361 0010 0F90      		pop __tmp_reg__
 2362 0012 0F90      		pop __tmp_reg__
 2363 0014 0F90      		pop __tmp_reg__
 2364 0016 0F90      		pop __tmp_reg__
 2365 0018 DF91      		pop r29
 2366 001a CF91      		pop r28
 2367 001c 0895      		ret
 2368               		.cfi_endproc
 2369               	.LFE36:
 2371               		.section	.text.debug_record,"ax",@progbits
 2372               	.global	debug_record
 2374               	debug_record:
 2375               	.LFB37:
1032:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1033:tmk_core/common/action.c ****  *
1034:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1035:tmk_core/common/action.c ****  */
1036:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2376               		.loc 1 1036 39 is_stmt 1 view -0
 2377               		.cfi_startproc
 2378 0000 CF93      		push r28
 2379               	.LCFI32:
 2380               		.cfi_def_cfa_offset 3
 2381               		.cfi_offset 28, -2
 2382 0002 DF93      		push r29
 2383               	.LCFI33:
 2384               		.cfi_def_cfa_offset 4
 2385               		.cfi_offset 29, -3
 2386 0004 00D0      		rcall .
 2387 0006 00D0      		rcall .
 2388 0008 00D0      		rcall .
 2389               	.LCFI34:
 2390               		.cfi_def_cfa_offset 10
 2391 000a CDB7      		in r28,__SP_L__
 2392 000c DEB7      		in r29,__SP_H__
 2393               	.LCFI35:
 2394               		.cfi_def_cfa_register 28
 2395               	/* prologue: function */
 2396               	/* frame size = 6 */
 2397               	/* stack size = 8 */
 2398               	.L__stack_usage = 8
1037:tmk_core/common/action.c ****     debug_event(record.event);
 2399               		.loc 1 1037 5 view .LVU605
1038:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1039:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2400               		.loc 1 1039 77 view .LVU606
 2401               	/* epilogue start */
1040:tmk_core/common/action.c **** #endif
1041:tmk_core/common/action.c **** }
 2402               		.loc 1 1041 1 is_stmt 0 view .LVU607
 2403 000e 2696      		adiw r28,6
 2404 0010 0FB6      		in __tmp_reg__,__SREG__
 2405 0012 F894      		cli
 2406 0014 DEBF      		out __SP_H__,r29
 2407 0016 0FBE      		out __SREG__,__tmp_reg__
 2408 0018 CDBF      		out __SP_L__,r28
 2409 001a DF91      		pop r29
 2410 001c CF91      		pop r28
 2411 001e 0895      		ret
 2412               		.cfi_endproc
 2413               	.LFE37:
 2415               		.section	.text.debug_action,"ax",@progbits
 2416               	.global	debug_action
 2418               	debug_action:
 2419               	.LVL236:
 2420               	.LFB38:
1042:tmk_core/common/action.c **** 
1043:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1044:tmk_core/common/action.c ****  *
1045:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1046:tmk_core/common/action.c ****  */
1047:tmk_core/common/action.c **** void debug_action(action_t action) {
 2421               		.loc 1 1047 36 is_stmt 1 view -0
 2422               		.cfi_startproc
 2423               	/* prologue: function */
 2424               	/* frame size = 0 */
 2425               	/* stack size = 0 */
 2426               	.L__stack_usage = 0
1048:tmk_core/common/action.c ****     switch (action.kind.id) {
 2427               		.loc 1 1048 5 view .LVU609
1049:tmk_core/common/action.c ****         case ACT_LMODS:
1050:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1051:tmk_core/common/action.c ****             break;
1052:tmk_core/common/action.c ****         case ACT_RMODS:
1053:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1054:tmk_core/common/action.c ****             break;
1055:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1056:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1057:tmk_core/common/action.c ****             break;
1058:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1059:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_USAGE:
1062:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1065:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_LAYER:
1068:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1071:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1074:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_MACRO:
1080:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_FUNCTION:
1083:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1086:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         default:
1089:tmk_core/common/action.c ****             dprint("UNKNOWN");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****     }
1092:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2428               		.loc 1 1092 75 view .LVU610
 2429               	/* epilogue start */
1093:tmk_core/common/action.c **** }
 2430               		.loc 1 1093 1 is_stmt 0 view .LVU611
 2431 0000 0895      		ret
 2432               		.cfi_endproc
 2433               	.LFE38:
 2435               		.section	.rodata.CSWTCH.12,"a"
 2438               	CSWTCH.12:
 2439 0000 E200      		.word	226
 2440 0002 E900      		.word	233
 2441 0004 EA00      		.word	234
 2442 0006 B500      		.word	181
 2443 0008 B600      		.word	182
 2444 000a B700      		.word	183
 2445 000c CD00      		.word	205
 2446 000e 8301      		.word	387
 2447 0010 CC00      		.word	204
 2448 0012 8A01      		.word	394
 2449 0014 9201      		.word	402
 2450 0016 9401      		.word	404
 2451 0018 2102      		.word	545
 2452 001a 2302      		.word	547
 2453 001c 2402      		.word	548
 2454 001e 2502      		.word	549
 2455 0020 2602      		.word	550
 2456 0022 2702      		.word	551
 2457 0024 2A02      		.word	554
 2458 0026 B300      		.word	179
 2459 0028 B400      		.word	180
 2460 002a 6F00      		.word	111
 2461 002c 7000      		.word	112
 2462               		.section	.rodata.CSWTCH.11,"a"
 2465               	CSWTCH.11:
 2466 0000 81        		.byte	-127
 2467 0001 82        		.byte	-126
 2468 0002 83        		.byte	-125
 2469               	.global	disable_action_cache
 2470               		.section	.bss.disable_action_cache,"aw",@nobits
 2473               	disable_action_cache:
 2474 0000 00        		.zero	1
 2475               		.comm	tp_buttons,2,1
 2476               		.text
 2477               	.Letext0:
 2478               		.file 5 "c:\\qmk_msys\\mingw64\\avr\\include\\stdint.h"
 2479               		.file 6 "tmk_core/common/keycode.h"
 2480               		.file 7 "tmk_core/common/host.h"
 2481               		.file 8 "quantum/mousekey.h"
 2482               		.file 9 "quantum/command.h"
 2483               		.file 10 "tmk_core/common/action_code.h"
 2484               		.file 11 "tmk_core/common/action.h"
 2485               		.file 12 "tmk_core/common/action_layer.h"
 2486               		.file 13 "tmk_core/common/action_util.h"
 2487               		.file 14 "tmk_core/common/debug.h"
 2488               		.file 15 "quantum/led.h"
 2489               		.file 16 "tmk_core/common/action_macro.h"
 2490               		.file 17 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:4      *ABS*:000000000000003f __SREG__
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:13     .text.action_exec:0000000000000000 action_exec
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:132    .text.process_record_quantum:0000000000000000 process_record_quantum
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:154    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:173    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:198    .text.register_code:0000000000000000 register_code
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2465   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2438   .rodata.CSWTCH.12:0000000000000000 CSWTCH.12
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:514    .text.unregister_code:0000000000000000 unregister_code
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:682    .text.tap_code_delay:0000000000000000 tap_code_delay
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:768    .text.tap_code:0000000000000000 tap_code
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:795    .text.register_mods:0000000000000000 register_mods
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:824    .text.unregister_mods:0000000000000000 unregister_mods
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:853    .text.process_action:0000000000000000 process_action
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:1956   .text.process_record:0000000000000000 process_record
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:1884   .text.process_record_handler:0000000000000000 process_record_handler
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2056   .text.process_record_nocache:0000000000000000 process_record_nocache
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2473   .bss.disable_action_cache:0000000000000000 disable_action_cache
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2084   .text.register_weak_mods:0000000000000000 register_weak_mods
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2113   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2142   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2181   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2201   .text.clear_keyboard:0000000000000000 clear_keyboard
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2221   .text.is_tap_action:0000000000000000 is_tap_action
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2309   .text.is_tap_key:0000000000000000 is_tap_key
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2332   .text.debug_event:0000000000000000 debug_event
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2374   .text.debug_record:0000000000000000 debug_record
C:\Users\xue\AppData\Local\Temp\ccJUusns.s:2418   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
clear_weak_mods
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
